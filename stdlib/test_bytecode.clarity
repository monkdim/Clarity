-- Bytecode Compiler & VM — test suite
-- Tests all node types: variables, arithmetic, functions, closures, control flow,
-- classes, try/catch, match, enums, comprehensions, pipes, destructuring, slicing.

from "lexer.clarity" import tokenize
from "parser.clarity" import parse
from "bytecode.clarity" import compile_to_bytecode, VM, optimize

mut passed = 0
mut failed = 0

fn run_bc(source) {
    let tokens = tokenize(source, "<test>")
    let tree = parse(tokens, source)
    let code = compile_to_bytecode(tree)
    optimize(code)
    let vm = VM()
    vm.run(code)
    return vm.output
}

fn assert_output(name, source, expected) {
    try {
        let output = run_bc(source)
        if output == expected {
            passed += 1
        } else {
            show "  FAIL: {name}"
            show "    expected: {expected}"
            show "    got:      {output}"
            failed += 1
        }
    } catch e {
        show "  ERROR: {name}: {e}"
        failed += 1
    }
}

fn assert_single(name, source, expected_line) {
    assert_output(name, source, [expected_line])
}

-- ── Section 1: Variables & Arithmetic ────────────────────

show "Section 1: Variables & Arithmetic"

assert_single("let binding", "let x = 42\nshow x", "42")
assert_single("mut binding", "mut x = 1\nx = 2\nshow x", "2")
assert_single("addition", "show 2 + 3", "5")
assert_single("subtraction", "show 10 - 4", "6")
assert_single("multiplication", "show 3 * 7", "21")
assert_single("division", "show 15 / 3", "5")
assert_single("modulo", "show 17 % 5", "2")
assert_single("power", "show 2 ** 10", "1024")
assert_single("negation", "show -(5 + 3)", "-8")
assert_single("compound add", "mut x = 10\nx += 5\nshow x", "15")
assert_single("compound sub", "mut x = 10\nx -= 3\nshow x", "7")
assert_single("compound mul", "mut x = 4\nx *= 3\nshow x", "12")
assert_single("string concat", "show \"hello\" + \" \" + \"world\"", "hello world")
assert_single("string number concat", "show \"count: \" + 42", "count: 42")

-- ── Section 2: Comparison & Logic ────────────────────────

show "Section 2: Comparison & Logic"

assert_single("equal true", "show 1 == 1", "true")
assert_single("equal false", "show 1 == 2", "false")
assert_single("not equal", "show 1 != 2", "true")
assert_single("less than", "show 3 < 5", "true")
assert_single("greater than", "show 5 > 3", "true")
assert_single("lte", "show 3 <= 3", "true")
assert_single("gte", "show 5 >= 5", "true")
assert_single("and true", "show true and true", "true")
assert_single("and false", "show true and false", "false")
assert_single("or true", "show false or true", "true")
assert_single("not", "show not false", "true")

-- ── Section 3: Control Flow ──────────────────────────────

show "Section 3: Control Flow"

assert_single("if true", "if true { show \"yes\" }", "yes")
assert_output("if else", "if false { show \"no\" } else { show \"yes\" }", ["yes"])
assert_single("if elif", "let x = 2\nif x == 1 { show \"one\" } elif x == 2 { show \"two\" } else { show \"other\" }", "two")

assert_single("while loop", "mut i = 0\nmut sum = 0\nwhile i < 5 { sum += i; i += 1 }\nshow sum", "10")
assert_single("for loop", "mut total = 0\nfor x in [1, 2, 3, 4, 5] { total += x }\nshow total", "15")
assert_single("for range", "mut s = 0\nfor i in range(5) { s += i }\nshow s", "10")

assert_single("break", "mut i = 0\nwhile true { if i >= 3 { break }; i += 1 }\nshow i", "3")
assert_single("continue", "mut sum = 0\nfor i in range(6) { if i % 2 == 0 { continue }; sum += i }\nshow sum", "9")

-- ── Section 4: Functions ─────────────────────────────────

show "Section 4: Functions"

assert_single("simple fn", "fn add(a, b) { return a + b }\nshow add(3, 4)", "7")
assert_single("fn no return", "fn greet(name) { show \"hi \" + name }\ngreet(\"bob\")", "hi bob")
assert_single("recursion", "fn fib(n) {\n  if n <= 1 { return n }\n  return fib(n - 1) + fib(n - 2)\n}\nshow fib(10)", "55")
assert_single("closure", "fn make_adder(n) { return fn(x) { return x + n } }\nlet add5 = make_adder(5)\nshow add5(10)", "15")
assert_single("higher order", "fn apply(f, x) { return f(x) }\nshow apply(fn(x) { return x * 2 }, 21)", "42")

-- ── Section 5: Collections ───────────────────────────────

show "Section 5: Collections"

assert_single("list literal", "show [1, 2, 3]", "[1, 2, 3]")
assert_single("list index", "let lst = [10, 20, 30]\nshow lst[1]", "20")
assert_single("map literal", "let m = {\"a\": 1, \"b\": 2}\nshow m[\"a\"]", "1")
assert_single("list push", "let lst = [1, 2]\npush(lst, 3)\nshow lst", "[1, 2, 3]")
assert_single("list len", "show len([1, 2, 3, 4])", "4")
assert_single("map keys", "let m = {\"x\": 1, \"y\": 2}\nshow len(keys(m))", "2")
assert_single("nested list", "let m = [[1, 2], [3, 4]]\nshow m[1][0]", "3")

-- ── Section 6: Strings ───────────────────────────────────

show "Section 6: Strings"

assert_single("upper", "show upper(\"hello\")", "HELLO")
assert_single("lower", "show lower(\"WORLD\")", "world")
assert_single("contains", "show contains(\"hello world\", \"world\")", "true")
assert_single("split join", "show join(split(\"a-b-c\", \"-\"), \", \")", "a, b, c")
assert_single("trim", "show trim(\"  hi  \")", "hi")
assert_single("replace", "show replace(\"hello\", \"l\", \"r\")", "herro")
assert_single("starts", "show starts(\"hello\", \"hel\")", "true")
assert_single("repeat", "show repeat(\"ab\", 3)", "ababab")

-- ── Section 7: Pipes ─────────────────────────────────────

show "Section 7: Pipes"

assert_single("simple pipe", "let result = 5 |> fn(x) { return x * 2 }\nshow result", "10")
assert_single("pipe chain", "let r = [3, 1, 2] |> sort |> reverse\nshow r", "[3, 2, 1]")

-- ── Section 8: If Expressions ────────────────────────────

show "Section 8: If Expressions"

assert_single("if expr true", "let x = if true { 1 } else { 2 }\nshow x", "1")
assert_single("if expr false", "let x = if false { 1 } else { 2 }\nshow x", "2")

-- ── Section 9: Classes ───────────────────────────────────

show "Section 9: Classes"

assert_output("class basic", "class Dog {\n  fn init(name) { this.name = name }\n  fn speak() { show this.name + \" says woof\" }\n}\nlet d = Dog(\"Rex\")\nd.speak()", ["Rex says woof"])

assert_single("class property", "class Point {\n  fn init(x, y) { this.x = x; this.y = y }\n  fn sum() { return this.x + this.y }\n}\nlet p = Point(3, 4)\nshow p.sum()", "7")

assert_output("class inheritance", "class Animal {\n  fn init(name) { this.name = name }\n  fn greet() { show \"I am \" + this.name }\n}\nclass Cat < Animal {\n  fn speak() { show this.name + \" meows\" }\n}\nlet c = Cat(\"Whiskers\")\nc.greet()\nc.speak()", ["I am Whiskers", "Whiskers meows"])

-- ── Section 10: Try/Catch ────────────────────────────────

show "Section 10: Try/Catch"

assert_single("try catch", "try {\n  throw \"oops\"\n} catch e {\n  show \"caught: \" + e\n}", "caught: oops")

assert_single("try no throw", "mut x = 0\ntry { x = 42 } catch e { x = -1 }\nshow x", "42")

-- ── Section 11: Null Coalesce ────────────────────────────

show "Section 11: Null Coalesce"

assert_single("null coalesce null", "let x = null ?? 5\nshow x", "5")
assert_single("null coalesce value", "let x = 3 ?? 5\nshow x", "3")

-- ── Section 12: Slicing ──────────────────────────────────

show "Section 12: Slicing"

assert_single("list slice", "let lst = [1, 2, 3, 4, 5]\nshow lst[1:3]", "[2, 3]")
assert_single("string slice", "show \"hello\"[1:4]", "ell")

-- ── Section 13: Destructuring ────────────────────────────

show "Section 13: Destructuring"

assert_single("list destruct", "let [a, b, c] = [1, 2, 3]\nshow a + b + c", "6")
assert_single("map destruct", "let {x, y} = {\"x\": 10, \"y\": 20}\nshow x + y", "30")
assert_single("rest destruct", "let [first, ...rest] = [1, 2, 3, 4]\nshow first\nshow rest", "1")

-- ── Section 14: Match ────────────────────────────────────

show "Section 14: Match"

assert_single("match literal", "let x = 2\nmatch x {\n  1 => { show \"one\" }\n  2 => { show \"two\" }\n  _ => { show \"other\" }\n}", "two")

assert_single("match default", "let x = 99\nmatch x {\n  1 => { show \"one\" }\n  _ => { show \"default\" }\n}", "default")

-- ── Section 15: Enums ────────────────────────────────────

show "Section 15: Enums"

assert_single("enum access", "enum Color { Red, Green, Blue }\nshow Color[\"Red\"]", "0")

-- ── Section 16: Optimizer ────────────────────────────────

show "Section 16: Optimizer"

assert_single("const fold add", "show 3 + 4", "7")
assert_single("const fold mul", "show 6 * 7", "42")
assert_single("const fold cmp", "show 5 > 3", "true")

-- ── Section 17: Integration ──────────────────────────────

show "Section 17: Integration"

assert_single("fibonacci 20", "fn fib(n) {\n  if n <= 1 { return n }\n  return fib(n - 1) + fib(n - 2)\n}\nshow fib(20)", "6765")

assert_single("bubble sort", "fn bsort(lst) {\n  mut arr = lst\n  mut n = len(arr)\n  mut i = 0\n  while i < n {\n    mut j = 0\n    while j < n - i - 1 {\n      if arr[j] > arr[j + 1] {\n        let tmp = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = tmp\n      }\n      j += 1\n    }\n    i += 1\n  }\n  return arr\n}\nshow bsort([5, 3, 8, 1, 2])", "[1, 2, 3, 5, 8]")

assert_single("counter class", "class Counter {\n  fn init() { this.count = 0 }\n  fn inc() { this.count += 1 }\n  fn get() { return this.count }\n}\nlet c = Counter()\nc.inc()\nc.inc()\nc.inc()\nshow c.get()", "3")

assert_single("map filter pipe", "let r = [1, 2, 3, 4, 5, 6] |> filter(fn(x) { return x % 2 == 0 }) |> map(fn(x) { return x * 10 })\nshow r", "[20, 40, 60]")

-- ── Summary ──────────────────────────────────────────────

show ""
show "Bytecode VM: {passed} passed, {failed} failed"
if failed > 0 { throw "Bytecode tests failed" }
