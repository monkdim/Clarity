-- Clarity Bytecode Compiler and Virtual Machine — self-hosting implementation
-- Complete bytecode compiler covering all 49 AST node types.
-- Includes: optimizer (constant folding, dead code elimination, peephole),
-- class/instance support, try/catch, break/continue, match, enums, comprehensions.
--
-- Usage:
--   from "bytecode.clarity" import compile_to_bytecode, VM, optimize
--   let code = compile_to_bytecode(ast_tree)
--   optimize(code)
--   let vm = VM()
--   vm.run(code)

-- ── Opcodes ──────────────────────────────────────────────

let OP_CONST = 0        -- Push constant from pool
let OP_POP = 1          -- Discard top of stack
let OP_ADD = 2
let OP_SUB = 3
let OP_MUL = 4
let OP_DIV = 5
let OP_MOD = 6
let OP_POW = 7
let OP_NEG = 8
let OP_NOT = 9
let OP_EQ = 10
let OP_NEQ = 11
let OP_LT = 12
let OP_GT = 13
let OP_LTE = 14
let OP_GTE = 15
let OP_LOAD = 16        -- Load variable by name (from constant pool)
let OP_STORE = 17       -- Store into existing variable
let OP_STORE_NEW = 18   -- Declare new variable
let OP_JUMP = 19        -- Unconditional jump
let OP_JUMP_FALSE = 20  -- Jump if top is falsy (pops)
let OP_CALL = 21        -- Call function with N args
let OP_RETURN = 22      -- Return from function
let OP_MAKE_LIST = 23   -- Create list from N items on stack
let OP_MAKE_MAP = 24    -- Create map from N key-value pairs on stack
let OP_GET_IDX = 25     -- Index access
let OP_SET_IDX = 26     -- Index assignment
let OP_GET_PROP = 27    -- Property access
let OP_SET_PROP = 28    -- Property assignment
let OP_PRINT = 29       -- Show statement — print N values
let OP_MAKE_FN = 30     -- Create function from code object
let OP_DUP = 31         -- Duplicate top
let OP_ITER_INIT = 32   -- Create iterator from iterable
let OP_ITER_NEXT = 33   -- Get next from iterator (pushes value + bool)
let OP_AND = 34
let OP_OR = 35
let OP_BIT_AND = 36
let OP_BIT_OR = 37
let OP_BIT_XOR = 38
let OP_BIT_NOT = 39
let OP_LSHIFT = 40
let OP_RSHIFT = 41
let OP_RANGE = 42       -- Create range from two ints
let OP_NULL = 43        -- Push null
let OP_TRUE = 44        -- Push true
let OP_FALSE = 45       -- Push false
let OP_CONCAT = 46      -- String concatenation
let OP_PIPE = 47        -- Pipe: call function with value as first arg
let OP_THROW = 48       -- Throw exception (pop value, throw it)
let OP_MAKE_CLASS = 49  -- Create class (operand = num_methods)
let OP_SLICE = 50       -- Slice: pop end, start, obj; push obj[start:end]
let OP_SETUP_TRY = 51   -- Set up try handler (operand = catch IP)
let OP_POP_TRY = 52     -- Remove try handler
let OP_SWAP = 53        -- Swap top two stack values
let OP_ROT3 = 54        -- Rotate top 3: [a, b, c] -> [c, a, b]
let OP_JUMP_TRUE = 55   -- Jump if top is truthy (pops)
let OP_HALT = 255

-- Opcode names for disassembly
let OP_NAMES = {
    0: "CONST", 1: "POP", 2: "ADD", 3: "SUB", 4: "MUL", 5: "DIV",
    6: "MOD", 7: "POW", 8: "NEG", 9: "NOT", 10: "EQ", 11: "NEQ",
    12: "LT", 13: "GT", 14: "LTE", 15: "GTE", 16: "LOAD", 17: "STORE",
    18: "STORE_NEW", 19: "JUMP", 20: "JUMP_FALSE", 21: "CALL", 22: "RETURN",
    23: "MAKE_LIST", 24: "MAKE_MAP", 25: "GET_IDX", 26: "SET_IDX",
    27: "GET_PROP", 28: "SET_PROP", 29: "PRINT", 30: "MAKE_FN", 31: "DUP",
    32: "ITER_INIT", 33: "ITER_NEXT", 34: "AND", 35: "OR", 36: "BIT_AND",
    37: "BIT_OR", 38: "BIT_XOR", 39: "BIT_NOT", 40: "LSHIFT", 41: "RSHIFT",
    42: "RANGE", 43: "NULL", 44: "TRUE", 45: "FALSE", 46: "CONCAT",
    47: "PIPE", 48: "THROW", 49: "MAKE_CLASS", 50: "SLICE",
    51: "SETUP_TRY", 52: "POP_TRY", 53: "SWAP", 54: "ROT3",
    55: "JUMP_TRUE", 255: "HALT"
}

-- ── Bytecode container ──────────────────────────────────

class CodeObject {
    fn init(name) {
        this.name = name ?? "<main>"
        this.instructions = []
        this.constants = []
        this.lines = []
    }

    fn emit(op, operand, line) {
        let op_val = op ?? 0
        let operand_val = operand ?? 0
        let line_val = line ?? 0
        push(this.instructions, [op_val, operand_val])
        push(this.lines, line_val)
        return len(this.instructions) - 1
    }

    fn add_const(value) {
        mut i = 0
        while i < len(this.constants) {
            let existing = this.constants[i]
            if type(existing) == type(value) {
                let t = type(value)
                if t == "number" or t == "string" or t == "bool" or t == "null" {
                    if existing == value {
                        return i
                    }
                }
            }
            i += 1
        }
        push(this.constants, value)
        return len(this.constants) - 1
    }

    fn patch_jump(idx) {
        let instr = this.instructions[idx]
        let op = instr[0]
        this.instructions[idx] = [op, len(this.instructions)]
    }

    fn disassemble() {
        mut lines = ["=== {this.name} ==="]
        push(lines, "Constants: {_bc_display_list(this.constants)}")
        mut i = 0
        while i < len(this.instructions) {
            let instr = this.instructions[i]
            let op = instr[0]
            let operand = instr[1]
            let name = if has(OP_NAMES, op) { OP_NAMES[op] } else { str(op) }
            mut extra = ""
            if op == OP_CONST or op == OP_LOAD or op == OP_STORE or op == OP_STORE_NEW or op == OP_GET_PROP or op == OP_SET_PROP {
                if operand < len(this.constants) {
                    extra = "  ; {_bc_repr(this.constants[operand])}"
                }
            }
            push(lines, "  {_pad_left(str(i), 4)}  {_pad_right(name, 14)} {_pad_right(str(operand), 6)}{extra}")
            i += 1
        }
        return join(lines, "\n")
    }
}

-- ── Compiler ─────────────────────────────────────────────

class Compiler {
    fn init() {
        this.code = CodeObject(null)
        this.loop_stack = []   -- [{start: int, break_patches: [int]}]
    }

    fn compile(program) {
        mut i = 0
        while i < len(program.body) {
            this.compile_node(program.body[i])
            i += 1
        }
        this.code.emit(OP_HALT)
        return this.code
    }

    fn compile_node(node) {
        let nt = node.node_type
        -- Statements
        if nt == "ExpressionStatement" { return this.compile_ExpressionStatement(node) }
        if nt == "LetStatement" { return this.compile_LetStatement(node) }
        if nt == "DestructureLetStatement" { return this.compile_DestructureLetStatement(node) }
        if nt == "AssignStatement" { return this.compile_AssignStatement(node) }
        if nt == "MultiAssignStatement" { return this.compile_MultiAssignStatement(node) }
        if nt == "FnStatement" { return this.compile_FnStatement(node) }
        if nt == "ReturnStatement" { return this.compile_ReturnStatement(node) }
        if nt == "ShowStatement" { return this.compile_ShowStatement(node) }
        if nt == "IfStatement" { return this.compile_IfStatement(node) }
        if nt == "WhileStatement" { return this.compile_WhileStatement(node) }
        if nt == "ForStatement" { return this.compile_ForStatement(node) }
        if nt == "TryCatch" { return this.compile_TryCatch(node) }
        if nt == "ThrowStatement" { return this.compile_ThrowStatement(node) }
        if nt == "BreakStatement" { return this.compile_BreakStatement(node) }
        if nt == "ContinueStatement" { return this.compile_ContinueStatement(node) }
        if nt == "ClassStatement" { return this.compile_ClassStatement(node) }
        if nt == "EnumStatement" { return this.compile_EnumStatement(node) }
        if nt == "InterfaceStatement" { return this.compile_InterfaceStatement(node) }
        if nt == "MatchStatement" { return this.compile_MatchStatement(node) }
        if nt == "ImportStatement" { return this.compile_ImportStatement(node) }
        if nt == "DecoratedStatement" { return this.compile_DecoratedStatement(node) }
        if nt == "Block" { return this.compile_Block(node) }
        -- Expressions
        if nt == "NumberLiteral" { return this.compile_NumberLiteral(node) }
        if nt == "StringLiteral" { return this.compile_StringLiteral(node) }
        if nt == "BoolLiteral" { return this.compile_BoolLiteral(node) }
        if nt == "NullLiteral" { return this.compile_NullLiteral(node) }
        if nt == "Identifier" { return this.compile_Identifier(node) }
        if nt == "ThisExpression" { return this.compile_ThisExpression(node) }
        if nt == "BinaryOp" { return this.compile_BinaryOp(node) }
        if nt == "UnaryOp" { return this.compile_UnaryOp(node) }
        if nt == "CallExpression" { return this.compile_CallExpression(node) }
        if nt == "ListLiteral" { return this.compile_ListLiteral(node) }
        if nt == "MapLiteral" { return this.compile_MapLiteral(node) }
        if nt == "IndexExpression" { return this.compile_IndexExpression(node) }
        if nt == "MemberExpression" { return this.compile_MemberExpression(node) }
        if nt == "OptionalMemberExpression" { return this.compile_OptionalMemberExpression(node) }
        if nt == "SliceExpression" { return this.compile_SliceExpression(node) }
        if nt == "RangeExpression" { return this.compile_RangeExpression(node) }
        if nt == "PipeExpression" { return this.compile_PipeExpression(node) }
        if nt == "FnExpression" { return this.compile_FnExpression(node) }
        if nt == "IfExpression" { return this.compile_IfExpression(node) }
        if nt == "NullCoalesce" { return this.compile_NullCoalesce(node) }
        if nt == "SpreadExpression" { return this.compile_SpreadExpression(node) }
        if nt == "ComprehensionExpression" { return this.compile_ComprehensionExpression(node) }
        if nt == "MapComprehensionExpression" { return this.compile_MapComprehensionExpression(node) }
        if nt == "AskExpression" { return this.compile_AskExpression(node) }
        if nt == "AwaitExpression" { return this.compile_AwaitExpression(node) }
        if nt == "YieldExpression" { return this.compile_YieldExpression(node) }
        throw "CompileError: Cannot compile node type: {nt}"
    }

    -- ── Statement compilers ─────────────────────────────

    fn compile_ExpressionStatement(node) {
        this.compile_node(node.expression)
        let line = node.line ?? 0
        this.code.emit(OP_POP, 0, line)
    }

    fn compile_LetStatement(node) {
        this.compile_node(node.value)
        let name_idx = this.code.add_const(node.name)
        let line = node.line ?? 0
        this.code.emit(OP_STORE_NEW, name_idx, line)
    }

    fn compile_DestructureLetStatement(node) {
        let line = node.line ?? 0
        this.compile_node(node.value)
        if node.kind == "list" {
            mut i = 0
            while i < len(node.targets) {
                let target = node.targets[i]
                if starts(target, "...") {
                    -- Rest: slice from i to end
                    let rest_name = substring(target, 3)
                    this.code.emit(OP_DUP, 0, line)
                    this.code.emit(OP_CONST, this.code.add_const(i), line)
                    this.code.emit(OP_NULL, 0, line)
                    this.code.emit(OP_SLICE, 0, line)
                    let name_idx = this.code.add_const(rest_name)
                    this.code.emit(OP_STORE_NEW, name_idx, line)
                    break
                } else {
                    this.code.emit(OP_DUP, 0, line)
                    this.code.emit(OP_CONST, this.code.add_const(i), line)
                    this.code.emit(OP_GET_IDX, 0, line)
                    let name_idx = this.code.add_const(target)
                    this.code.emit(OP_STORE_NEW, name_idx, line)
                }
                i += 1
            }
        } elif node.kind == "map" {
            mut i = 0
            while i < len(node.targets) {
                let target = node.targets[i]
                this.code.emit(OP_DUP, 0, line)
                let key_idx = this.code.add_const(target)
                this.code.emit(OP_CONST, key_idx, line)
                this.code.emit(OP_GET_IDX, 0, line)
                let name_idx = this.code.add_const(target)
                this.code.emit(OP_STORE_NEW, name_idx, line)
                i += 1
            }
        }
        this.code.emit(OP_POP, 0, line)
    }

    fn compile_AssignStatement(node) {
        let target = node.target
        let line = node.line ?? 0

        if target.node_type == "Identifier" {
            if node.operator == "=" {
                this.compile_node(node.value)
            } else {
                -- Compound: load current, compile value, apply op
                let name_idx = this.code.add_const(target.name)
                this.code.emit(OP_LOAD, name_idx, line)
                this.compile_node(node.value)
                if node.operator == "+=" { this.code.emit(OP_ADD, 0, line) }
                elif node.operator == "-=" { this.code.emit(OP_SUB, 0, line) }
                elif node.operator == "*=" { this.code.emit(OP_MUL, 0, line) }
                elif node.operator == "/=" { this.code.emit(OP_DIV, 0, line) }
                elif node.operator == "%=" { this.code.emit(OP_MOD, 0, line) }
            }
            let name_idx = this.code.add_const(target.name)
            this.code.emit(OP_STORE, name_idx, line)
        } elif target.node_type == "IndexExpression" {
            this.compile_node(target.object)
            this.compile_node(target.index)
            if node.operator == "=" {
                this.compile_node(node.value)
            } else {
                -- Compound: obj[idx] op= val
                this.code.emit(OP_DUP, 0, line)       -- dup idx
                this.code.emit(OP_ROT3, 0, line)       -- rotate to get obj on top
                this.code.emit(OP_DUP, 0, line)        -- dup obj
                this.code.emit(OP_ROT3, 0, line)       -- bring idx up
                this.code.emit(OP_GET_IDX, 0, line)    -- get current value
                this.compile_node(node.value)
                if node.operator == "+=" { this.code.emit(OP_ADD, 0, line) }
                elif node.operator == "-=" { this.code.emit(OP_SUB, 0, line) }
                elif node.operator == "*=" { this.code.emit(OP_MUL, 0, line) }
                elif node.operator == "/=" { this.code.emit(OP_DIV, 0, line) }
            }
            this.code.emit(OP_SET_IDX, 0, line)
        } elif target.node_type == "MemberExpression" {
            this.compile_node(target.object)
            let prop_idx = this.code.add_const(target.property)
            if node.operator == "=" {
                this.compile_node(node.value)
            } else {
                this.code.emit(OP_DUP, 0, line)
                this.code.emit(OP_GET_PROP, prop_idx, line)
                this.compile_node(node.value)
                if node.operator == "+=" { this.code.emit(OP_ADD, 0, line) }
                elif node.operator == "-=" { this.code.emit(OP_SUB, 0, line) }
                elif node.operator == "*=" { this.code.emit(OP_MUL, 0, line) }
                elif node.operator == "/=" { this.code.emit(OP_DIV, 0, line) }
            }
            this.code.emit(OP_SET_PROP, prop_idx, line)
        }
    }

    fn compile_MultiAssignStatement(node) {
        let line = node.line ?? 0
        -- Evaluate all values first
        mut i = 0
        while i < len(node.values) {
            this.compile_node(node.values[i])
            i += 1
        }
        -- Store in reverse order (values are on stack top-down)
        mut j = len(node.targets) - 1
        while j >= 0 {
            let target = node.targets[j]
            if target.node_type == "Identifier" {
                let name_idx = this.code.add_const(target.name)
                this.code.emit(OP_STORE, name_idx, line)
            }
            j -= 1
        }
    }

    fn compile_FnStatement(node) {
        this._compile_function(node.name, node.params, node.body)
        let line = node.line ?? 0
        let name_idx = this.code.add_const(node.name)
        this.code.emit(OP_STORE_NEW, name_idx, line)
    }

    fn _compile_function(name, params, body) {
        let fn_compiler = Compiler()
        fn_compiler.code = CodeObject(name ?? "<lambda>")
        mut i = 0
        while i < len(body.statements) {
            fn_compiler.compile_node(body.statements[i])
            i += 1
        }
        fn_compiler.code.emit(OP_CONST, fn_compiler.code.add_const(null))
        fn_compiler.code.emit(OP_RETURN)
        let fn_code_idx = this.code.add_const(fn_compiler.code)
        let params_idx = this.code.add_const(params)
        let line = body.line ?? 0
        this.code.emit(OP_MAKE_FN, fn_code_idx, line)
    }

    fn compile_ReturnStatement(node) {
        if node.value != null {
            this.compile_node(node.value)
        } else {
            this.code.emit(OP_NULL)
        }
        let line = node.line ?? 0
        this.code.emit(OP_RETURN, 0, line)
    }

    fn compile_ShowStatement(node) {
        mut i = 0
        while i < len(node.values) {
            this.compile_node(node.values[i])
            i += 1
        }
        let line = node.line ?? 0
        this.code.emit(OP_PRINT, len(node.values), line)
    }

    fn compile_IfStatement(node) {
        let line = node.line ?? 0
        this.compile_node(node.condition)
        let jump_false = this.code.emit(OP_JUMP_FALSE, 0, line)
        this.compile_block(node.body)
        let jump_end = this.code.emit(OP_JUMP, 0)
        this.code.patch_jump(jump_false)

        if has(node, "elif_clauses") and node.elif_clauses != null and len(node.elif_clauses) > 0 {
            mut ei = 0
            mut elif_end_jumps = []
            while ei < len(node.elif_clauses) {
                let clause = node.elif_clauses[ei]
                let elif_cond = clause[0]
                let elif_body = clause[1]
                this.compile_node(elif_cond)
                let elif_jump_false = this.code.emit(OP_JUMP_FALSE, 0, line)
                this.compile_block(elif_body)
                let elif_jump_end = this.code.emit(OP_JUMP, 0)
                push(elif_end_jumps, elif_jump_end)
                this.code.patch_jump(elif_jump_false)
                ei += 1
            }
            if node.else_body != null {
                this.compile_block(node.else_body)
            }
            mut ji = 0
            while ji < len(elif_end_jumps) {
                this.code.patch_jump(elif_end_jumps[ji])
                ji += 1
            }
        } else {
            if node.else_body != null {
                this.compile_block(node.else_body)
            }
        }
        this.code.patch_jump(jump_end)
    }

    fn compile_WhileStatement(node) {
        let line = node.line ?? 0
        let loop_start = len(this.code.instructions)
        push(this.loop_stack, {"start": loop_start, "break_patches": []})

        this.compile_node(node.condition)
        let jump_false = this.code.emit(OP_JUMP_FALSE, 0, line)
        this.compile_block(node.body)
        this.code.emit(OP_JUMP, loop_start)
        this.code.patch_jump(jump_false)

        let loop_ctx = pop(this.loop_stack)
        mut bi = 0
        while bi < len(loop_ctx["break_patches"]) {
            this.code.patch_jump(loop_ctx["break_patches"][bi])
            bi += 1
        }
    }

    fn compile_ForStatement(node) {
        let line = node.line ?? 0
        this.compile_node(node.iterable)
        this.code.emit(OP_ITER_INIT, 0, line)
        let loop_start = len(this.code.instructions)
        push(this.loop_stack, {"start": loop_start, "break_patches": []})

        this.code.emit(OP_DUP)
        this.code.emit(OP_ITER_NEXT)
        let jump_end = this.code.emit(OP_JUMP_FALSE, 0)
        let name_idx = this.code.add_const(node.variable)
        this.code.emit(OP_STORE_NEW, name_idx)
        this.compile_block(node.body)
        this.code.emit(OP_JUMP, loop_start)
        this.code.patch_jump(jump_end)
        this.code.emit(OP_POP)   -- pop iterator

        let loop_ctx = pop(this.loop_stack)
        mut bi = 0
        while bi < len(loop_ctx["break_patches"]) {
            this.code.patch_jump(loop_ctx["break_patches"][bi])
            bi += 1
        }
    }

    fn compile_BreakStatement(node) {
        let line = node.line ?? 0
        if len(this.loop_stack) > 0 {
            let loop_ctx = this.loop_stack[len(this.loop_stack) - 1]
            let patch_idx = this.code.emit(OP_JUMP, 0, line)
            push(loop_ctx["break_patches"], patch_idx)
        }
    }

    fn compile_ContinueStatement(node) {
        let line = node.line ?? 0
        if len(this.loop_stack) > 0 {
            let loop_ctx = this.loop_stack[len(this.loop_stack) - 1]
            this.code.emit(OP_JUMP, loop_ctx["start"], line)
        }
    }

    fn compile_TryCatch(node) {
        let line = node.line ?? 0
        let try_start = this.code.emit(OP_SETUP_TRY, 0, line)
        this.compile_block(node.try_body)
        this.code.emit(OP_POP_TRY, 0, line)
        let jump_end = this.code.emit(OP_JUMP, 0)
        -- Patch try handler to point here (catch block)
        this.code.patch_jump(try_start)
        -- Store error into catch variable
        if node.catch_var != null {
            let var_idx = this.code.add_const(node.catch_var)
            this.code.emit(OP_STORE_NEW, var_idx, line)
        } else {
            this.code.emit(OP_POP, 0, line)
        }
        this.compile_block(node.catch_body)
        this.code.patch_jump(jump_end)
    }

    fn compile_ThrowStatement(node) {
        let line = node.line ?? 0
        this.compile_node(node.value)
        this.code.emit(OP_THROW, 0, line)
    }

    fn compile_ClassStatement(node) {
        let line = node.line ?? 0
        -- Push class name
        let name_idx = this.code.add_const(node.name)
        this.code.emit(OP_CONST, name_idx, line)
        -- Push parent class or null
        if node.parent != null {
            let parent_idx = this.code.add_const(node.parent)
            this.code.emit(OP_LOAD, parent_idx, line)
        } else {
            this.code.emit(OP_NULL, 0, line)
        }
        -- Compile each method
        let methods = node.methods
        mut i = 0
        while i < len(methods) {
            let method = methods[i]
            let method_name_idx = this.code.add_const(method.name)
            this.code.emit(OP_CONST, method_name_idx, line)
            this._compile_function(method.name, method.params, method.body)
            i += 1
        }
        this.code.emit(OP_MAKE_CLASS, len(methods), line)
        this.code.emit(OP_STORE_NEW, name_idx, line)
    }

    fn compile_EnumStatement(node) {
        let line = node.line ?? 0
        let name_idx = this.code.add_const(node.name)
        -- Build enum as map: {member_name: member_value, ...}
        this.code.emit(OP_CONST, name_idx, line)
        mut i = 0
        while i < len(node.members) {
            let member = node.members[i]
            let mem_name = if type(member) == "list" { member[0] } else { member }
            let mem_name_idx = this.code.add_const(mem_name)
            this.code.emit(OP_CONST, mem_name_idx, line)
            if type(member) == "list" and len(member) > 1 {
                this.compile_node(member[1])
            } else {
                this.code.emit(OP_CONST, this.code.add_const(i), line)
            }
            i += 1
        }
        this.code.emit(OP_MAKE_MAP, len(node.members), line)
        -- Store as {__enum__: name, members: map}
        this.code.emit(OP_SWAP, 0, line)
        this.code.emit(OP_POP, 0, line)
        this.code.emit(OP_STORE_NEW, name_idx, line)
    }

    fn compile_InterfaceStatement(node) {
        let line = node.line ?? 0
        let name_idx = this.code.add_const(node.name)
        -- Interfaces compile as a map of method signatures
        mut i = 0
        while i < len(node.methods) {
            let method = node.methods[i]
            let m_name = if type(method) == "map" and has(method, "name") { method["name"] } else { str(method) }
            this.code.emit(OP_CONST, this.code.add_const(m_name), line)
            this.code.emit(OP_TRUE, 0, line)
            i += 1
        }
        this.code.emit(OP_MAKE_MAP, len(node.methods), line)
        this.code.emit(OP_STORE_NEW, name_idx, line)
    }

    fn compile_MatchStatement(node) {
        let line = node.line ?? 0
        this.compile_node(node.value)
        -- Compile as chain of compare-and-jump
        mut end_jumps = []
        mut i = 0
        while i < len(node.arms) {
            let arm = node.arms[i]
            let pattern = arm[0]
            let body = arm[1]
            -- Check if this is the default/wildcard arm
            let is_default = (type(pattern) == "map" and has(pattern, "node_type") and pattern.node_type == "Identifier" and pattern.name == "_")
            if is_default {
                this.code.emit(OP_POP, 0, line)
                this.compile_block(body)
                let jump_end = this.code.emit(OP_JUMP, 0)
                push(end_jumps, jump_end)
            } else {
                this.code.emit(OP_DUP, 0, line)
                this.compile_node(pattern)
                this.code.emit(OP_EQ, 0, line)
                let jump_miss = this.code.emit(OP_JUMP_FALSE, 0, line)
                this.code.emit(OP_POP, 0, line)
                this.compile_block(body)
                let jump_end = this.code.emit(OP_JUMP, 0)
                push(end_jumps, jump_end)
                this.code.patch_jump(jump_miss)
            }
            i += 1
        }
        -- Pop the match value if no arm matched
        this.code.emit(OP_POP, 0, line)
        -- Patch all end jumps
        mut ji = 0
        while ji < len(end_jumps) {
            this.code.patch_jump(end_jumps[ji])
            ji += 1
        }
    }

    fn compile_ImportStatement(node) {
        -- Imports are resolved at the interpreter/runtime level.
        -- In bytecode VM mode, we skip imports (they should be pre-resolved).
        return null
    }

    fn compile_DecoratedStatement(node) {
        let line = node.line ?? 0
        -- Compile the inner statement first (defines the function)
        this.compile_node(node.statement)
        -- Apply decorators in reverse order
        mut i = len(node.decorators) - 1
        while i >= 0 {
            let decorator = node.decorators[i]
            -- Load the decorator function
            this.compile_node(decorator)
            -- Load the function we just defined
            -- The function was stored via STORE_NEW, so we load it back
            if node.statement.node_type == "FnStatement" {
                let name_idx = this.code.add_const(node.statement.name)
                this.code.emit(OP_LOAD, name_idx, line)
            }
            -- Call decorator with the function as argument
            this.code.emit(OP_CALL, 1, line)
            -- Store the result back
            if node.statement.node_type == "FnStatement" {
                let name_idx = this.code.add_const(node.statement.name)
                this.code.emit(OP_STORE, name_idx, line)
            } else {
                this.code.emit(OP_POP, 0, line)
            }
            i -= 1
        }
    }

    fn compile_block(block) {
        mut i = 0
        while i < len(block.statements) {
            this.compile_node(block.statements[i])
            i += 1
        }
    }

    fn compile_Block(node) {
        this.compile_block(node)
    }

    -- ── Expression compilers ────────────────────────────

    fn compile_NumberLiteral(node) {
        let idx = this.code.add_const(node.value)
        let line = node.line ?? 0
        this.code.emit(OP_CONST, idx, line)
    }

    fn compile_StringLiteral(node) {
        let idx = this.code.add_const(node.value)
        let line = node.line ?? 0
        this.code.emit(OP_CONST, idx, line)
    }

    fn compile_BoolLiteral(node) {
        let line = node.line ?? 0
        if node.value { this.code.emit(OP_TRUE, 0, line) }
        else { this.code.emit(OP_FALSE, 0, line) }
    }

    fn compile_NullLiteral(node) {
        let line = node.line ?? 0
        this.code.emit(OP_NULL, 0, line)
    }

    fn compile_Identifier(node) {
        let idx = this.code.add_const(node.name)
        let line = node.line ?? 0
        this.code.emit(OP_LOAD, idx, line)
    }

    fn compile_ThisExpression(node) {
        let idx = this.code.add_const("this")
        let line = node.line ?? 0
        this.code.emit(OP_LOAD, idx, line)
    }

    fn compile_BinaryOp(node) {
        let line = node.line ?? 0
        let op = node.operator
        this.compile_node(node.left)
        this.compile_node(node.right)

        if op == "+" { this.code.emit(OP_ADD, 0, line) }
        elif op == "-" { this.code.emit(OP_SUB, 0, line) }
        elif op == "*" { this.code.emit(OP_MUL, 0, line) }
        elif op == "/" { this.code.emit(OP_DIV, 0, line) }
        elif op == "%" { this.code.emit(OP_MOD, 0, line) }
        elif op == "**" { this.code.emit(OP_POW, 0, line) }
        elif op == "==" { this.code.emit(OP_EQ, 0, line) }
        elif op == "!=" { this.code.emit(OP_NEQ, 0, line) }
        elif op == "<" { this.code.emit(OP_LT, 0, line) }
        elif op == ">" { this.code.emit(OP_GT, 0, line) }
        elif op == "<=" { this.code.emit(OP_LTE, 0, line) }
        elif op == ">=" { this.code.emit(OP_GTE, 0, line) }
        elif op == "and" { this.code.emit(OP_AND, 0, line) }
        elif op == "or" { this.code.emit(OP_OR, 0, line) }
        elif op == "&" { this.code.emit(OP_BIT_AND, 0, line) }
        elif op == "|" { this.code.emit(OP_BIT_OR, 0, line) }
        elif op == "^" { this.code.emit(OP_BIT_XOR, 0, line) }
        elif op == "<<" { this.code.emit(OP_LSHIFT, 0, line) }
        elif op == ">>" { this.code.emit(OP_RSHIFT, 0, line) }
        else { throw "CompileError: Unknown binary operator: {op}" }
    }

    fn compile_UnaryOp(node) {
        let line = node.line ?? 0
        this.compile_node(node.operand)
        if node.operator == "-" { this.code.emit(OP_NEG, 0, line) }
        elif node.operator == "not" { this.code.emit(OP_NOT, 0, line) }
        elif node.operator == "~" { this.code.emit(OP_BIT_NOT, 0, line) }
    }

    fn compile_CallExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.callee)
        mut i = 0
        while i < len(node.arguments) {
            this.compile_node(node.arguments[i])
            i += 1
        }
        this.code.emit(OP_CALL, len(node.arguments), line)
    }

    fn compile_ListLiteral(node) {
        let line = node.line ?? 0
        mut i = 0
        while i < len(node.elements) {
            this.compile_node(node.elements[i])
            i += 1
        }
        this.code.emit(OP_MAKE_LIST, len(node.elements), line)
    }

    fn compile_MapLiteral(node) {
        let line = node.line ?? 0
        mut i = 0
        while i < len(node.pairs) {
            let pair = node.pairs[i]
            this.compile_node(pair[0])
            this.compile_node(pair[1])
            i += 1
        }
        this.code.emit(OP_MAKE_MAP, len(node.pairs), line)
    }

    fn compile_IndexExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.object)
        this.compile_node(node.index)
        this.code.emit(OP_GET_IDX, 0, line)
    }

    fn compile_MemberExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.object)
        let prop_idx = this.code.add_const(node.property)
        this.code.emit(OP_GET_PROP, prop_idx, line)
    }

    fn compile_OptionalMemberExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.object)
        -- If null, skip property access and leave null on stack
        this.code.emit(OP_DUP, 0, line)
        this.code.emit(OP_NULL, 0, line)
        this.code.emit(OP_EQ, 0, line)
        let jump_null = this.code.emit(OP_JUMP_TRUE, 0, line)
        let prop_idx = this.code.add_const(node.property)
        this.code.emit(OP_GET_PROP, prop_idx, line)
        let jump_end = this.code.emit(OP_JUMP, 0)
        this.code.patch_jump(jump_null)
        -- Already null on stack, just leave it
        this.code.patch_jump(jump_end)
    }

    fn compile_SliceExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.object)
        if node.start != null {
            this.compile_node(node.start)
        } else {
            this.code.emit(OP_CONST, this.code.add_const(0), line)
        }
        if node.end != null {
            this.compile_node(node.end)
        } else {
            this.code.emit(OP_NULL, 0, line)
        }
        this.code.emit(OP_SLICE, 0, line)
    }

    fn compile_RangeExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.start)
        if node.end != null {
            this.compile_node(node.end)
        } else {
            this.code.emit(OP_NULL)
        }
        this.code.emit(OP_RANGE, 0, line)
    }

    fn compile_PipeExpression(node) {
        let line = node.line ?? 0
        this.compile_node(node.value)
        if node.function.node_type == "CallExpression" {
            this.compile_node(node.function.callee)
            mut i = 0
            while i < len(node.function.arguments) {
                this.compile_node(node.function.arguments[i])
                i += 1
            }
            this.code.emit(OP_PIPE, len(node.function.arguments) + 1, line)
        } else {
            this.compile_node(node.function)
            this.code.emit(OP_CALL, 1, line)
        }
    }

    fn compile_FnExpression(node) {
        let line = node.line ?? 0
        let fn_compiler = Compiler()
        fn_compiler.code = CodeObject("<lambda>")
        mut i = 0
        while i < len(node.body.statements) {
            fn_compiler.compile_node(node.body.statements[i])
            i += 1
        }
        fn_compiler.code.emit(OP_CONST, fn_compiler.code.add_const(null))
        fn_compiler.code.emit(OP_RETURN)
        let fn_code_idx = this.code.add_const(fn_compiler.code)
        let params_idx = this.code.add_const(node.params)
        this.code.emit(OP_MAKE_FN, fn_code_idx, line)
    }

    fn compile_IfExpression(node) {
        this.compile_node(node.condition)
        let jump_false = this.code.emit(OP_JUMP_FALSE, 0)
        this.compile_node(node.true_expr)
        let jump_end = this.code.emit(OP_JUMP, 0)
        this.code.patch_jump(jump_false)
        this.compile_node(node.false_expr)
        this.code.patch_jump(jump_end)
    }

    fn compile_NullCoalesce(node) {
        let line = node.line ?? 0
        this.compile_node(node.left)
        -- If not null, skip right side
        this.code.emit(OP_DUP, 0, line)
        this.code.emit(OP_NULL, 0, line)
        this.code.emit(OP_NEQ, 0, line)
        let jump_done = this.code.emit(OP_JUMP_TRUE, 0, line)
        -- Left was null, pop it and use right
        this.code.emit(OP_POP, 0, line)
        this.compile_node(node.right)
        this.code.patch_jump(jump_done)
    }

    fn compile_SpreadExpression(node) {
        -- Spread just evaluates the inner expression
        this.compile_node(node.value)
    }

    fn compile_ComprehensionExpression(node) {
        let line = node.line ?? 0
        -- [expr for var in iterable] or [expr for var in iterable if cond]
        this.code.emit(OP_MAKE_LIST, 0, line)   -- result list
        this.compile_node(node.iterable)
        this.code.emit(OP_ITER_INIT, 0, line)
        let loop_start = len(this.code.instructions)
        this.code.emit(OP_DUP)
        this.code.emit(OP_ITER_NEXT)
        let jump_end = this.code.emit(OP_JUMP_FALSE, 0)
        let var_idx = this.code.add_const(node.variable)
        this.code.emit(OP_STORE_NEW, var_idx)
        -- Check filter condition if present
        mut jump_skip = -1
        if node.condition != null {
            this.compile_node(node.condition)
            jump_skip = this.code.emit(OP_JUMP_FALSE, 0)
        }
        -- Evaluate expression and append to result
        -- We need the result list: it's below the iterator on the stack
        -- Stack: [..., result_list, iterator]
        -- After ITER_NEXT and STORE_NEW: [..., result_list, iterator]
        -- We swap to get result_list, compile expr, push onto it, swap back
        this.code.emit(OP_SWAP, 0, line)       -- [..., iterator, result_list]
        this.compile_node(node.expression)      -- [..., iterator, result_list, value]
        -- Use a builtin push: load push, call with (list, value)
        let push_idx = this.code.add_const("push")
        this.code.emit(OP_LOAD, push_idx, line)
        this.code.emit(OP_ROT3, 0, line)       -- get args in order
        this.code.emit(OP_ROT3, 0, line)
        this.code.emit(OP_CALL, 2, line)
        this.code.emit(OP_POP, 0, line)         -- pop push return value
        this.code.emit(OP_SWAP, 0, line)         -- [..., result_list, iterator]
        if jump_skip >= 0 {
            let after_push = len(this.code.instructions)
            this.code.patch_jump(jump_skip)
        }
        this.code.emit(OP_JUMP, loop_start)
        this.code.patch_jump(jump_end)
        this.code.emit(OP_POP)   -- pop iterator, result_list remains
    }

    fn compile_MapComprehensionExpression(node) {
        let line = node.line ?? 0
        this.code.emit(OP_MAKE_MAP, 0, line)    -- result map
        this.compile_node(node.iterable)
        this.code.emit(OP_ITER_INIT, 0, line)
        let loop_start = len(this.code.instructions)
        this.code.emit(OP_DUP)
        this.code.emit(OP_ITER_NEXT)
        let jump_end = this.code.emit(OP_JUMP_FALSE, 0)
        let var_idx = this.code.add_const(node.variable)
        this.code.emit(OP_STORE_NEW, var_idx)
        mut jump_skip = -1
        if node.condition != null {
            this.compile_node(node.condition)
            jump_skip = this.code.emit(OP_JUMP_FALSE, 0)
        }
        -- Evaluate key and value expressions
        this.code.emit(OP_SWAP, 0, line)
        this.code.emit(OP_DUP, 0, line)
        this.code.emit(OP_ROT3, 0, line)
        this.compile_node(node.key)
        this.compile_node(node.value_expr)
        this.code.emit(OP_SET_IDX, 0, line)
        this.code.emit(OP_SWAP, 0, line)
        if jump_skip >= 0 {
            this.code.patch_jump(jump_skip)
        }
        this.code.emit(OP_JUMP, loop_start)
        this.code.patch_jump(jump_end)
        this.code.emit(OP_POP)
    }

    fn compile_AskExpression(node) {
        let line = node.line ?? 0
        let ask_idx = this.code.add_const("ask")
        this.code.emit(OP_LOAD, ask_idx, line)
        if node.prompt != null {
            this.compile_node(node.prompt)
        } else {
            this.code.emit(OP_CONST, this.code.add_const(""), line)
        }
        this.code.emit(OP_CALL, 1, line)
    }

    fn compile_AwaitExpression(node) {
        -- Await in bytecode mode just evaluates the expression
        this.compile_node(node.value)
    }

    fn compile_YieldExpression(node) {
        -- Yield in bytecode mode evaluates and returns
        if node.value != null {
            this.compile_node(node.value)
        } else {
            this.code.emit(OP_NULL)
        }
    }
}

-- ── VM Types ─────────────────────────────────────────────

class VMFrame {
    fn init(code, base_pointer) {
        this.code = code
        this.ip = 0
        this.locals = {}
        this.base_pointer = base_pointer ?? 0
    }
}

class VMFunction {
    fn init(code, params, name) {
        this.code = code
        this.params = params
        this.name = name ?? "<fn>"
    }

    fn to_string() {
        return "<compiled fn {this.name}>"
    }
}

class VMClass {
    fn init(name, methods, parent) {
        this.name = name
        this.methods = methods
        this.parent = parent ?? null
    }

    fn find_method(name) {
        if has(this.methods, name) {
            return this.methods[name]
        }
        if this.parent != null {
            return this.parent.find_method(name)
        }
        return null
    }

    fn to_string() {
        return "<class {this.name}>"
    }
}

class VMInstance {
    fn init(klass) {
        this.klass = klass
        this.properties = {}
    }

    fn get_prop(name) {
        if has(this.properties, name) {
            return this.properties[name]
        }
        let method = this.klass.find_method(name)
        if method != null {
            return method
        }
        return null
    }

    fn to_string() {
        return "<{this.klass.name} instance>"
    }
}

class VMIterator {
    fn init(items) {
        this.items = items
        this.index = 0
    }

    fn has_next() {
        return this.index < len(this.items)
    }

    fn next() {
        let val = this.items[this.index]
        this.index = this.index + 1
        return val
    }
}

-- ── Virtual Machine ──────────────────────────────────────

class VM {
    fn init() {
        this.stack = []
        this.frames = []
        this.globals = {}
        this.output = []
        this.try_stack = []   -- [{catch_ip: int, stack_depth: int, frame_depth: int}]
        this._setup_builtins()
    }

    fn _setup_builtins() {
        let vm = this

        this.globals["len"] = fn(x) { return len(x) }
        this.globals["push"] = fn(lst, item) { push(lst, item); return lst }
        this.globals["pop"] = fn(lst) { return pop(lst) }
        this.globals["str"] = fn(x) { return vm._display(x) }
        this.globals["int"] = fn(x) { return int(x) }
        this.globals["float"] = fn(x) { return float(x) }
        this.globals["type"] = fn(x) { return vm._type_name(x) }
        this.globals["range"] = fn(...a) {
            if len(a) == 1 { return range(a[0]) }
            if len(a) == 2 { return range(a[0], a[1]) }
            if len(a) == 3 { return range(a[0], a[1], a[2]) }
            throw "range() takes 1-3 arguments"
        }
        this.globals["map"] = fn(lst, f) {
            return map(lst, fn(x) { return vm._call_fn(f, [x]) })
        }
        this.globals["filter"] = fn(lst, f) {
            return filter(lst, fn(x) { return vm._is_truthy(vm._call_fn(f, [x])) })
        }
        this.globals["sort"] = fn(lst) { return sort(lst) }
        this.globals["reverse"] = fn(lst) { return reverse(lst) }
        this.globals["keys"] = fn(m) { return keys(m) }
        this.globals["values"] = fn(m) { return values(m) }
        this.globals["entries"] = fn(m) { return entries(m) }
        this.globals["has"] = fn(col, key) { return has(col, key) }
        this.globals["sum"] = fn(lst) { return sum(lst) }
        this.globals["abs"] = fn(n) { return abs(n) }
        this.globals["min"] = fn(...a) {
            if len(a) == 1 and type(a[0]) == "list" { return min(a[0]) }
            return min(...a)
        }
        this.globals["max"] = fn(...a) {
            if len(a) == 1 and type(a[0]) == "list" { return max(a[0]) }
            return max(...a)
        }
        this.globals["join"] = fn(lst, sep) {
            let s = sep ?? ""
            return join(map(lst, fn(x) { return vm._display(x) }), s)
        }
        this.globals["split"] = fn(s, sep) { return split(s, sep ?? " ") }
        this.globals["trim"] = fn(s) { return trim(s) }
        this.globals["upper"] = fn(s) { return upper(s) }
        this.globals["lower"] = fn(s) { return lower(s) }
        this.globals["contains"] = fn(h, n) { return contains(h, n) }
        this.globals["starts"] = fn(s, p) { return starts(s, p) }
        this.globals["ends"] = fn(s, p) { return ends(s, p) }
        this.globals["replace"] = fn(s, old, new_s) { return replace(s, old, new_s) }
        this.globals["chars"] = fn(s) { return chars(s) }
        this.globals["char_at"] = fn(s, i) { return char_at(s, i) }
        this.globals["char_code"] = fn(c) { return char_code(c) }
        this.globals["from_char_code"] = fn(n) { return from_char_code(n) }
        this.globals["index_of"] = fn(s, sub) { return index_of(s, sub) }
        this.globals["substring"] = fn(s, start, end_idx) { return substring(s, start, end_idx) }
        this.globals["is_digit"] = fn(c) { return is_digit(c) }
        this.globals["is_alpha"] = fn(c) { return is_alpha(c) }
        this.globals["is_alnum"] = fn(c) { return is_alnum(c) }
        this.globals["is_space"] = fn(c) { return is_space(c) }
        this.globals["repeat"] = fn(s, n) { return repeat(s, n) }
        this.globals["each"] = fn(lst, f) {
            each(lst, fn(x) { vm._call_fn(f, [x]) })
        }
        this.globals["find"] = fn(lst, f) {
            return find(lst, fn(x) { return vm._is_truthy(vm._call_fn(f, [x])) })
        }
        this.globals["every"] = fn(lst, f) {
            return every(lst, fn(x) { return vm._is_truthy(vm._call_fn(f, [x])) })
        }
        this.globals["some"] = fn(lst, f) {
            return some(lst, fn(x) { return vm._is_truthy(vm._call_fn(f, [x])) })
        }
        this.globals["reduce"] = fn(lst, f, initial) {
            mut acc = if initial != null { initial } else { lst[0] }
            mut start = if initial != null { 0 } else { 1 }
            mut i = start
            while i < len(lst) {
                acc = vm._call_fn(f, [acc, lst[i]])
                i += 1
            }
            return acc
        }
        this.globals["flat"] = fn(lst) { return flat(lst) }
        this.globals["unique"] = fn(lst) { return unique(lst) }
        this.globals["merge"] = fn(...maps) { return merge(...maps) }
        this.globals["zip"] = fn(...lists) { return zip(...lists) }

        -- Math
        this.globals["pi"] = pi
        this.globals["e"] = e
        this.globals["sqrt"] = fn(n) { return sqrt(n) }
        this.globals["sin"] = fn(n) { return sin(n) }
        this.globals["cos"] = fn(n) { return cos(n) }
        this.globals["tan"] = fn(n) { return tan(n) }
        this.globals["log"] = fn(n) { return log(n) }
        this.globals["pow"] = fn(a, b) { return pow(a, b) }
        this.globals["floor"] = fn(n) { return floor(n) }
        this.globals["ceil"] = fn(n) { return ceil(n) }
        this.globals["round"] = fn(n) { return round(n) }
        this.globals["random"] = fn(...a) { return random(...a) }

        -- I/O
        this.globals["print"] = fn(...args) {
            let out = join(map(args, fn(a) { return vm._display(a) }), " ")
            show out
            push(vm.output, out)
        }
        this.globals["show"] = fn(...args) {
            let out = join(map(args, fn(a) { return vm._display(a) }), " ")
            show out
            push(vm.output, out)
        }
        this.globals["ask"] = fn(prompt) { return ask(vm._display(prompt ?? "")) }

        -- Type conversions
        this.globals["bool"] = fn(v) { return vm._is_truthy(v) }

        -- System
        this.globals["exec"] = fn(cmd) { return exec(cmd) }
        this.globals["exec_full"] = fn(cmd) { return exec_full(cmd) }
        this.globals["exit"] = fn(code) { exit(code ?? 0) }
        this.globals["sleep"] = fn(s) { sleep(s) }
        this.globals["time"] = fn() { return time() }
        this.globals["env"] = fn(k, d) { return env(k, d) }
        this.globals["cwd"] = fn() { return cwd() }
        this.globals["args"] = fn() { return args() }

        -- File I/O
        this.globals["read"] = fn(p) { return read(p) }
        this.globals["write"] = fn(p, c) { return write(p, c) }
        this.globals["append"] = fn(p, c) { return append(p, c) }
        this.globals["exists"] = fn(p) { return exists(p) }
        this.globals["lines"] = fn(p) { return lines(p) }

        -- JSON
        this.globals["json_parse"] = fn(t) { return json_parse(t) }
        this.globals["json_string"] = fn(v) { return json_string(v) }

        -- Errors
        this.globals["error"] = fn(msg) { return str(msg) }
    }

    fn _call_fn(f, call_args) {
        let t = type(f)
        if t == "VMFunction" {
            return this._call_vm_fn(f, call_args)
        }
        if t == "VMClass" {
            return this._instantiate_class(f, call_args)
        }
        if t == "function" or t == "builtin" {
            return f(...call_args)
        }
        throw "RuntimeError: Not callable: {this._display(f)}"
    }

    fn _instantiate_class(klass, call_args) {
        let instance = VMInstance(klass)
        let init_method = klass.find_method("init")
        if init_method != null {
            this._call_method(instance, init_method, call_args)
        }
        return instance
    }

    fn _call_method(instance, method, call_args) {
        let frame = VMFrame(method.code, len(this.stack))
        frame.locals["this"] = instance
        let params = if type(method.params) == "list" { method.params } else { [] }
        mut i = 0
        while i < len(params) {
            let val = if i < len(call_args) { call_args[i] } else { null }
            frame.locals[params[i]] = val
            i += 1
        }
        push(this.frames, frame)
        try {
            let result = this._execute_frame()
            pop(this.frames)
            return result
        } catch err {
            pop(this.frames)
            throw err
        }
    }

    fn _call_vm_fn(f, call_args) {
        let frame = VMFrame(f.code, len(this.stack))
        let params = if type(f.params) == "list" { f.params } else { [] }
        mut i = 0
        while i < len(params) {
            let val = if i < len(call_args) { call_args[i] } else { null }
            frame.locals[params[i]] = val
            i += 1
        }
        push(this.frames, frame)
        try {
            let result = this._execute_frame()
            pop(this.frames)
            return result
        } catch err {
            pop(this.frames)
            throw err
        }
    }

    fn run(code) {
        let frame = VMFrame(code)
        let gkeys = keys(this.globals)
        mut i = 0
        while i < len(gkeys) {
            let k = gkeys[i]
            frame.locals[k] = this.globals[k]
            i += 1
        }
        push(this.frames, frame)
        try {
            let result = this._execute_frame()
            pop(this.frames)
            return result
        } catch err {
            pop(this.frames)
            throw err
        }
    }

    fn _execute_frame() {
        let frame = this.frames[len(this.frames) - 1]
        let code = frame.code

        while frame.ip < len(code.instructions) {
            let instr = code.instructions[frame.ip]
            let op = instr[0]
            let operand = instr[1]
            frame.ip = frame.ip + 1

            if op == OP_HALT {
                if len(this.stack) > 0 { return this.stack[len(this.stack) - 1] }
                return null
            }

            elif op == OP_CONST { push(this.stack, code.constants[operand]) }
            elif op == OP_NULL { push(this.stack, null) }
            elif op == OP_TRUE { push(this.stack, true) }
            elif op == OP_FALSE { push(this.stack, false) }

            elif op == OP_POP {
                if len(this.stack) > 0 { pop(this.stack) }
            }
            elif op == OP_DUP {
                push(this.stack, this.stack[len(this.stack) - 1])
            }
            elif op == OP_SWAP {
                let a = pop(this.stack)
                let b = pop(this.stack)
                push(this.stack, a)
                push(this.stack, b)
            }
            elif op == OP_ROT3 {
                let c = pop(this.stack)
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, c)
                push(this.stack, a)
                push(this.stack, b)
            }

            -- Variables
            elif op == OP_LOAD {
                let name = code.constants[operand]
                if has(frame.locals, name) {
                    push(this.stack, frame.locals[name])
                } elif has(this.globals, name) {
                    push(this.stack, this.globals[name])
                } else {
                    -- Walk up frames for closure variables
                    mut found = false
                    mut fi = len(this.frames) - 2
                    while fi >= 0 {
                        let parent_frame = this.frames[fi]
                        if has(parent_frame.locals, name) {
                            push(this.stack, parent_frame.locals[name])
                            found = true
                            break
                        }
                        fi -= 1
                    }
                    if not found {
                        throw "RuntimeError: Undefined variable: {name}"
                    }
                }
            }
            elif op == OP_STORE {
                let name = code.constants[operand]
                let value = this.stack[len(this.stack) - 1]
                -- Check current frame first, then walk up
                if has(frame.locals, name) {
                    frame.locals[name] = value
                } else {
                    mut found = false
                    mut fi = len(this.frames) - 2
                    while fi >= 0 {
                        if has(this.frames[fi].locals, name) {
                            this.frames[fi].locals[name] = value
                            found = true
                            break
                        }
                        fi -= 1
                    }
                    if not found {
                        frame.locals[name] = value
                    }
                }
            }
            elif op == OP_STORE_NEW {
                let name = code.constants[operand]
                let value = pop(this.stack)
                frame.locals[name] = value
            }

            -- Arithmetic
            elif op == OP_ADD {
                let b = pop(this.stack)
                let a = pop(this.stack)
                if type(a) == "string" or type(b) == "string" {
                    push(this.stack, this._display(a) + this._display(b))
                } elif type(a) == "list" and type(b) == "list" {
                    push(this.stack, a + b)
                } else {
                    push(this.stack, a + b)
                }
            }
            elif op == OP_SUB {
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, a - b)
            }
            elif op == OP_MUL {
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, a * b)
            }
            elif op == OP_DIV {
                let b = pop(this.stack)
                let a = pop(this.stack)
                if b == 0 { throw "RuntimeError: Division by zero" }
                let result = a / b
                if result == floor(result) {
                    push(this.stack, int(result))
                } else {
                    push(this.stack, result)
                }
            }
            elif op == OP_MOD {
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, a % b)
            }
            elif op == OP_POW {
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, pow(a, b))
            }
            elif op == OP_NEG { push(this.stack, -pop(this.stack)) }
            elif op == OP_NOT { push(this.stack, not this._is_truthy(pop(this.stack))) }

            -- Comparison
            elif op == OP_EQ { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a == b) }
            elif op == OP_NEQ { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a != b) }
            elif op == OP_LT { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a < b) }
            elif op == OP_GT { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a > b) }
            elif op == OP_LTE { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a <= b) }
            elif op == OP_GTE { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, a >= b) }

            -- Logical
            elif op == OP_AND {
                let b = pop(this.stack)
                let a = pop(this.stack)
                if this._is_truthy(a) { push(this.stack, b) }
                else { push(this.stack, a) }
            }
            elif op == OP_OR {
                let b = pop(this.stack)
                let a = pop(this.stack)
                if this._is_truthy(a) { push(this.stack, a) }
                else { push(this.stack, b) }
            }

            -- Bitwise
            elif op == OP_BIT_AND { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, int(a) & int(b)) }
            elif op == OP_BIT_OR { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, int(a) | int(b)) }
            elif op == OP_BIT_XOR { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, int(a) ^ int(b)) }
            elif op == OP_BIT_NOT { push(this.stack, ~int(pop(this.stack))) }
            elif op == OP_LSHIFT { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, int(a) << int(b)) }
            elif op == OP_RSHIFT { let b = pop(this.stack); let a = pop(this.stack); push(this.stack, int(a) >> int(b)) }

            -- Control flow
            elif op == OP_JUMP { frame.ip = operand }
            elif op == OP_JUMP_FALSE {
                if not this._is_truthy(pop(this.stack)) { frame.ip = operand }
            }
            elif op == OP_JUMP_TRUE {
                if this._is_truthy(pop(this.stack)) { frame.ip = operand }
            }

            -- Functions
            elif op == OP_MAKE_FN {
                let fn_code = code.constants[operand]
                mut params = []
                if operand + 1 < len(code.constants) {
                    let maybe_params = code.constants[operand + 1]
                    if type(maybe_params) == "list" {
                        mut is_param_list = true
                        mut pi = 0
                        while pi < len(maybe_params) {
                            if type(maybe_params[pi]) != "string" {
                                is_param_list = false
                                break
                            }
                            pi += 1
                        }
                        if is_param_list { params = maybe_params }
                    }
                }
                let vm_fn = VMFunction(fn_code, params, fn_code.name)
                push(this.stack, vm_fn)
            }
            elif op == OP_CALL {
                let nargs = operand
                mut call_args = []
                mut ai = 0
                while ai < nargs {
                    push(call_args, pop(this.stack))
                    ai += 1
                }
                call_args = reverse(call_args)
                let callee = pop(this.stack)
                let result = this._call_fn(callee, call_args)
                push(this.stack, result)
            }
            elif op == OP_RETURN {
                if len(this.stack) > 0 { return pop(this.stack) }
                return null
            }

            -- Collections
            elif op == OP_MAKE_LIST {
                mut items = []
                mut li = 0
                while li < operand {
                    push(items, pop(this.stack))
                    li += 1
                }
                items = reverse(items)
                push(this.stack, items)
            }
            elif op == OP_MAKE_MAP {
                mut pairs = []
                mut mi = 0
                while mi < operand {
                    let v = pop(this.stack)
                    let k = pop(this.stack)
                    push(pairs, [k, v])
                    mi += 1
                }
                pairs = reverse(pairs)
                let result_map = {}
                mut mj = 0
                while mj < len(pairs) {
                    let pair = pairs[mj]
                    result_map[pair[0]] = pair[1]
                    mj += 1
                }
                push(this.stack, result_map)
            }
            elif op == OP_GET_IDX {
                let idx = pop(this.stack)
                let obj = pop(this.stack)
                let t = type(obj)
                if t == "list" { push(this.stack, obj[idx]) }
                elif t == "map" {
                    if has(obj, idx) { push(this.stack, obj[idx]) }
                    else { push(this.stack, null) }
                }
                elif t == "string" { push(this.stack, obj[idx]) }
                else { throw "RuntimeError: Cannot index into {t}" }
            }
            elif op == OP_SET_IDX {
                let value = pop(this.stack)
                let idx = pop(this.stack)
                let obj = pop(this.stack)
                obj[idx] = value
            }
            elif op == OP_GET_PROP {
                let prop = code.constants[operand]
                let obj = pop(this.stack)
                let t = type(obj)
                if t == "VMInstance" {
                    let val = obj.get_prop(prop)
                    push(this.stack, val)
                } elif t == "map" {
                    if has(obj, prop) { push(this.stack, obj[prop]) }
                    else { push(this.stack, null) }
                } elif t == "list" {
                    if prop == "length" { push(this.stack, len(obj)) }
                    elif prop == "first" {
                        if len(obj) > 0 { push(this.stack, obj[0]) }
                        else { push(this.stack, null) }
                    }
                    elif prop == "last" {
                        if len(obj) > 0 { push(this.stack, obj[len(obj) - 1]) }
                        else { push(this.stack, null) }
                    }
                    else { throw "RuntimeError: List has no property '{prop}'" }
                } elif t == "string" {
                    if prop == "length" { push(this.stack, len(obj)) }
                    elif prop == "upper" { push(this.stack, upper(obj)) }
                    elif prop == "lower" { push(this.stack, lower(obj)) }
                    else { throw "RuntimeError: String has no property '{prop}'" }
                } elif t == "VMClass" {
                    -- Static access / enum-like access
                    if has(obj.methods, prop) { push(this.stack, obj.methods[prop]) }
                    else { push(this.stack, null) }
                } else {
                    throw "RuntimeError: Cannot access property '{prop}' on {t}"
                }
            }
            elif op == OP_SET_PROP {
                let prop = code.constants[operand]
                let value = pop(this.stack)
                let obj = pop(this.stack)
                let t = type(obj)
                if t == "VMInstance" {
                    obj.properties[prop] = value
                } elif t == "map" {
                    obj[prop] = value
                } else {
                    throw "RuntimeError: Cannot set property '{prop}' on {t}"
                }
            }

            -- Range
            elif op == OP_RANGE {
                let end_val = pop(this.stack)
                let start_val = pop(this.stack)
                if end_val == null { push(this.stack, range(start_val, start_val)) }
                else { push(this.stack, range(start_val, end_val)) }
            }

            -- Slice
            elif op == OP_SLICE {
                let end_val = pop(this.stack)
                let start_val = pop(this.stack)
                let obj = pop(this.stack)
                let t = type(obj)
                if t == "list" {
                    let actual_end = if end_val == null { len(obj) } else { end_val }
                    mut sliced = []
                    mut si = start_val
                    while si < actual_end and si < len(obj) {
                        push(sliced, obj[si])
                        si += 1
                    }
                    push(this.stack, sliced)
                } elif t == "string" {
                    let actual_end = if end_val == null { len(obj) } else { end_val }
                    push(this.stack, substring(obj, start_val, actual_end))
                } else {
                    throw "RuntimeError: Cannot slice {t}"
                }
            }

            -- Print (show)
            elif op == OP_PRINT {
                mut print_vals = []
                mut pi = 0
                while pi < operand {
                    push(print_vals, pop(this.stack))
                    pi += 1
                }
                print_vals = reverse(print_vals)
                let out = join(map(print_vals, fn(v) { return this._display(v) }), " ")
                show out
                push(this.output, out)
            }

            -- Iteration
            elif op == OP_ITER_INIT {
                let iterable = pop(this.stack)
                let iter = VMIterator(iterable)
                push(this.stack, iter)
            }
            elif op == OP_ITER_NEXT {
                let iterator = this.stack[len(this.stack) - 1]
                if iterator.has_next() {
                    let value = iterator.next()
                    push(this.stack, value)
                    push(this.stack, true)
                } else {
                    push(this.stack, false)
                }
            }

            -- String concatenation
            elif op == OP_CONCAT {
                let b = pop(this.stack)
                let a = pop(this.stack)
                push(this.stack, this._display(a) + this._display(b))
            }

            -- Pipe
            elif op == OP_PIPE {
                let nargs = operand
                mut pipe_args = []
                mut pai = 0
                while pai < nargs {
                    push(pipe_args, pop(this.stack))
                    pai += 1
                }
                pipe_args = reverse(pipe_args)
                let callee = pop(this.stack)
                let piped_value = if len(pipe_args) > 0 { pipe_args[0] } else { null }
                mut full_args = [piped_value]
                mut fai = 1
                while fai < len(pipe_args) {
                    push(full_args, pipe_args[fai])
                    fai += 1
                }
                let result = this._call_fn(callee, full_args)
                push(this.stack, result)
            }

            -- Throw
            elif op == OP_THROW {
                let err_val = pop(this.stack)
                throw this._display(err_val)
            }

            -- Class creation
            elif op == OP_MAKE_CLASS {
                let num_methods = operand
                mut method_pairs = []
                mut ci = 0
                while ci < num_methods {
                    let method_fn = pop(this.stack)
                    let method_name = pop(this.stack)
                    push(method_pairs, [method_name, method_fn])
                    ci += 1
                }
                method_pairs = reverse(method_pairs)
                let parent = pop(this.stack)
                let class_name = pop(this.stack)
                let methods = {}
                mut mi = 0
                while mi < len(method_pairs) {
                    let pair = method_pairs[mi]
                    methods[pair[0]] = pair[1]
                    mi += 1
                }
                let parent_class = if type(parent) == "VMClass" { parent } else { null }
                let klass = VMClass(class_name, methods, parent_class)
                push(this.stack, klass)
            }

            -- Try/catch
            elif op == OP_SETUP_TRY {
                push(this.try_stack, {
                    "catch_ip": operand,
                    "stack_depth": len(this.stack),
                    "frame_idx": len(this.frames) - 1
                })
            }
            elif op == OP_POP_TRY {
                if len(this.try_stack) > 0 {
                    pop(this.try_stack)
                }
            }

            else {
                throw "RuntimeError: Unknown opcode: {op}"
            }
        }

        if len(this.stack) > 0 { return this.stack[len(this.stack) - 1] }
        return null
    }

    -- ── Helper methods ──────────────────────────────────

    fn _is_truthy(value) {
        if value == null { return false }
        let t = type(value)
        if t == "bool" { return value }
        if t == "number" { return value != 0 }
        if t == "string" { return len(value) > 0 }
        if t == "list" { return len(value) > 0 }
        if t == "map" { return len(keys(value)) > 0 }
        return true
    }

    fn _display(value) {
        if value == null { return "null" }
        let t = type(value)
        if t == "bool" {
            if value { return "true" }
            return "false"
        }
        if t == "number" {
            if value == floor(value) { return str(int(value)) }
            return str(value)
        }
        if t == "string" { return value }
        if t == "list" {
            let items = join(map(value, fn(v) { return this._repr(v) }), ", ")
            return "[{items}]"
        }
        if t == "map" {
            let ks = keys(value)
            let pair_strs = map(ks, fn(k) {
                return "{k}: {this._repr(value[k])}"
            })
            return "\{" + join(pair_strs, ", ") + "\}"
        }
        if t == "VMFunction" { return value.to_string() }
        if t == "VMClass" { return value.to_string() }
        if t == "VMInstance" { return value.to_string() }
        return str(value)
    }

    fn _repr(value) {
        if type(value) == "string" { return "\"{value}\"" }
        return this._display(value)
    }

    fn _type_name(value) {
        if value == null { return "null" }
        let t = type(value)
        if t == "bool" { return "bool" }
        if t == "number" {
            if value == floor(value) { return "int" }
            return "float"
        }
        if t == "string" { return "string" }
        if t == "list" { return "list" }
        if t == "map" { return "map" }
        if t == "function" or t == "builtin" { return "function" }
        if t == "VMFunction" { return "function" }
        if t == "VMClass" { return "class" }
        if t == "VMInstance" { return value.klass.name }
        return "unknown"
    }
}

-- ── Optimizer ────────────────────────────────────────────

fn optimize(code) {
    -- Run all optimization passes on a CodeObject.
    _constant_fold(code)
    _dead_code_eliminate(code)
    _peephole(code)
    return code
}

fn _constant_fold(code) {
    -- Fold constant binary operations at bytecode level.
    -- Pattern: CONST a, CONST b, OP -> CONST (a OP b)
    mut i = 0
    while i + 2 < len(code.instructions) {
        let i0 = code.instructions[i]
        let i1 = code.instructions[i + 1]
        let i2 = code.instructions[i + 2]

        if i0[0] == OP_CONST and i1[0] == OP_CONST {
            let a = code.constants[i0[1]]
            let b = code.constants[i1[1]]
            let op = i2[0]

            if type(a) == "number" and type(b) == "number" {
                mut result = null
                mut folded = false

                if op == OP_ADD { result = a + b; folded = true }
                elif op == OP_SUB { result = a - b; folded = true }
                elif op == OP_MUL { result = a * b; folded = true }
                elif op == OP_DIV and b != 0 {
                    result = a / b
                    if result == floor(result) { result = int(result) }
                    folded = true
                }
                elif op == OP_MOD and b != 0 { result = a % b; folded = true }
                elif op == OP_POW { result = pow(a, b); folded = true }
                elif op == OP_EQ { result = a == b; folded = true }
                elif op == OP_NEQ { result = a != b; folded = true }
                elif op == OP_LT { result = a < b; folded = true }
                elif op == OP_GT { result = a > b; folded = true }
                elif op == OP_LTE { result = a <= b; folded = true }
                elif op == OP_GTE { result = a >= b; folded = true }

                if folded {
                    if type(result) == "bool" {
                        if result {
                            code.instructions[i] = [OP_TRUE, 0]
                        } else {
                            code.instructions[i] = [OP_FALSE, 0]
                        }
                    } else {
                        let result_idx = code.add_const(result)
                        code.instructions[i] = [OP_CONST, result_idx]
                    }
                    -- NOP out the other two instructions
                    code.instructions[i + 1] = [OP_POP, 0]
                    code.instructions[i + 2] = [OP_POP, 0]
                    -- Actually, we should replace them with nothing.
                    -- Since we can't remove instructions (would break jumps),
                    -- we'll push+pop which is a no-op. But better: push result once.
                    -- The CONST at i pushes the folded result.
                    -- i+1 and i+2 need to be skipped: use NOP pattern
                    -- NOP = POP after a needed value is wasteful.
                    -- Just leave as POP,POP — they'll be cleaned by peephole.
                }
            }
        }
        i += 1
    }
}

fn _dead_code_eliminate(code) {
    -- After RETURN or THROW, mark subsequent non-jump-target instructions.
    -- We mark them as NOPs (POP with nothing to pop is harmless).
    -- First, collect all jump targets
    let targets = {}
    mut i = 0
    while i < len(code.instructions) {
        let instr = code.instructions[i]
        let op = instr[0]
        if op == OP_JUMP or op == OP_JUMP_FALSE or op == OP_JUMP_TRUE or op == OP_SETUP_TRY {
            targets[instr[1]] = true
        }
        i += 1
    }

    -- Now scan for RETURN/THROW and NOP out dead code until a jump target
    i = 0
    while i < len(code.instructions) {
        let op = code.instructions[i][0]
        if op == OP_RETURN or op == OP_THROW or op == OP_HALT {
            mut j = i + 1
            while j < len(code.instructions) {
                if has(targets, j) { break }
                -- Don't NOP out HALTs
                if code.instructions[j][0] != OP_HALT {
                    code.instructions[j] = [OP_POP, 0]
                }
                j += 1
            }
            i = j
        } else {
            i += 1
        }
    }
}

fn _peephole(code) {
    -- Peephole optimizations:
    -- 1. Remove consecutive POP,POP when stack is likely empty (from constant folding)
    -- 2. CONST x, POP -> (NOP both) — dead expression
    -- 3. DUP, POP -> (NOP both)
    mut i = 0
    while i + 1 < len(code.instructions) {
        let i0 = code.instructions[i]
        let i1 = code.instructions[i + 1]

        -- CONST followed by POP = dead load
        if i0[0] == OP_CONST and i1[0] == OP_POP {
            -- Check this isn't a jump target
            -- (simplified: just do it, the semantics are preserved)
            code.instructions[i] = [OP_POP, 0]
            -- Two consecutive POPs from empty stack are harmless
        }

        -- DUP followed by POP = no-op
        if i0[0] == OP_DUP and i1[0] == OP_POP {
            code.instructions[i] = [OP_POP, 0]
        }

        i += 1
    }
}

-- ── Helper functions ────────────────────────────────────

fn _pad_left(s, width) {
    mut result = s
    while len(result) < width { result = " " + result }
    return result
}

fn _pad_right(s, width) {
    mut result = s
    while len(result) < width { result = result + " " }
    return result
}

fn _bc_display_list(lst) {
    let items = map(lst, fn(v) { return _bc_repr(v) })
    return "[" + join(items, ", ") + "]"
}

fn _bc_repr(value) {
    if value == null { return "null" }
    let t = type(value)
    if t == "string" { return "\"{value}\"" }
    if t == "bool" {
        if value { return "true" }
        return "false"
    }
    if t == "number" { return str(value) }
    if t == "list" { return _bc_display_list(value) }
    if t == "CodeObject" { return "<code {value.name}>" }
    return str(value)
}

-- ── Public API ───────────────────────────────────────────

fn compile_to_bytecode(program) {
    let compiler = Compiler()
    return compiler.compile(program)
}
