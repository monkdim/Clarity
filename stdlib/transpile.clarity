-- Clarity-to-JavaScript Transpiler — self-hosted implementation
-- Faithful port of native/transpile.py, written in Clarity itself.
-- Reads Clarity source, parses to AST, emits JavaScript.

from "lexer.clarity" import tokenize
from "parser.clarity" import parse

-- ── JS Reserved Word Mapping ────────────────────────────

let JS_RESERVED = {
    "int": "$int", "float": "$float", "bool": "$bool",
    "set": "$set", "min": "$min", "max": "$max",
    "join": "$join", "repeat": "$repeat",
    "class": "$class", "new": "$new", "delete": "$delete",
    "switch": "$switch", "case": "$case", "default": "$default",
    "typeof": "$typeof", "void": "$void", "with": "$with",
    "yield": "$yield", "debugger": "$debugger",
    "instanceof": "$instanceof", "in": "$in",
    "var": "$var", "const": "$const"
}

-- ── Runtime Import Header ───────────────────────────────

let RUNTIME_HEADER = "// Generated by Clarity transpiler — do not edit
import { show as $show, ask as $ask, read, write, append, exists, lines,
  $int, $float, str, $bool, type, len, push, pop, sort, reverse, range as $range,
  map, filter, reduce, each, find, every, some, flat, zip, unique,
  keys, values, entries, merge, has, split, $join, replace, trim,
  upper, lower, contains, starts, ends, chars, $repeat,
  pad_left, pad_right, char_at, char_code, from_char_code, index_of, substring,
  is_digit, is_alpha, is_alnum, is_space,
  abs, round, floor, ceil, $min, $max, sum, random, pow,
  pi, e, sqrt, sin, cos, tan, log,
  exec, exec_full, exit, sleep, time, env, args, cwd,
  json_parse, json_string, hash, encode64, decode64,
  fetch, serve, compose, tap, $set, error as $error,
  display, repr, truthy as $truthy, ClarityEnum as $ClarityEnum,
  ClarityInstance as $ClarityInstance,
  formatClarityError, clarityMain
} from \"./runtime.js\";

"

-- ── Stdlib Bundle File List ─────────────────────────────

let STDLIB_FILES = [
    "tokens.clarity", "lexer.clarity", "ast_nodes.clarity",
    "parser.clarity", "interpreter.clarity", "terminal.clarity",
    "process.clarity", "shell.clarity", "repl.clarity",
    "package.clarity", "lsp.clarity", "bytecode.clarity",
    "runtime.clarity",
    "linter.clarity", "formatter.clarity", "type_checker.clarity",
    "docgen.clarity", "debugger.clarity", "profiler.clarity",
    "collections.clarity", "datetime.clarity", "path.clarity",
    "net.clarity", "db.clarity", "crypto.clarity",
    "semver.clarity", "registry.clarity",
    "highlight.clarity", "completer.clarity", "pretty.clarity",
    "channel.clarity", "task.clarity", "mutex.clarity", "worker.clarity",
    "transpile.clarity",
    "build.clarity", "test_smoke.clarity",
    "runtime_spec.clarity", "runtime_gen.clarity",
    "install.clarity",
    "cli.clarity"
]

-- ── JSEmitter ───────────────────────────────────────────

class JSEmitter {
    fn init(module_name) {
        this.indent_level = 0
        this.module_name = module_name ?? "<main>"
        this.classes = []
        this.hoisted_imports = []
    }

    -- ── Main entry ──────────────────────────────────────

    fn emit(program) {
        mut lines = []
        for stmt in program.body {
            push(lines, this.emit_stmt(stmt))
        }
        if len(this.hoisted_imports) > 0 {
            let hoisted = join(this.hoisted_imports, "\n")
            return hoisted + "\n" + join(lines, "\n")
        }
        return join(lines, "\n")
    }

    fn _indent() {
        return repeat("  ", this.indent_level)
    }

    -- ── Statement dispatch ──────────────────────────────

    fn emit_stmt(node) {
        let nt = node.node_type
        mut result = ""

        if nt == "ExpressionStatement" { result = this.stmt_ExpressionStatement(node) }
        elif nt == "LetStatement" { result = this.stmt_LetStatement(node) }
        elif nt == "DestructureLetStatement" { result = this.stmt_DestructureLetStatement(node) }
        elif nt == "AssignStatement" { result = this.stmt_AssignStatement(node) }
        elif nt == "MultiAssignStatement" { result = this.stmt_MultiAssignStatement(node) }
        elif nt == "FnStatement" { result = this.stmt_FnStatement(node) }
        elif nt == "ReturnStatement" { result = this.stmt_ReturnStatement(node) }
        elif nt == "IfStatement" { result = this.stmt_IfStatement(node) }
        elif nt == "ForStatement" { result = this.stmt_ForStatement(node) }
        elif nt == "WhileStatement" { result = this.stmt_WhileStatement(node) }
        elif nt == "TryCatch" { result = this.stmt_TryCatch(node) }
        elif nt == "BreakStatement" { result = this._indent() + "break;" }
        elif nt == "ContinueStatement" { result = this._indent() + "continue;" }
        elif nt == "ThrowStatement" { result = this.stmt_ThrowStatement(node) }
        elif nt == "ShowStatement" { result = this.stmt_ShowStatement(node) }
        elif nt == "ImportStatement" { result = this.stmt_ImportStatement(node) }
        elif nt == "ClassStatement" { result = this.stmt_ClassStatement(node) }
        elif nt == "InterfaceStatement" { result = this._indent() + "/* interface " + node.name + " */" }
        elif nt == "MatchStatement" { result = this.stmt_MatchStatement(node) }
        elif nt == "EnumStatement" { result = this.stmt_EnumStatement(node) }
        elif nt == "DecoratedStatement" { result = this.stmt_DecoratedStatement(node) }
        elif nt == "Block" { result = this._emit_block_body(node) }
        else { result = this._indent() + "/* TODO: " + nt + " */" }

        -- Emit source location comment for debuggable stack traces
        let line = node.line
        if line != null {
            result = this._indent() + "/*@" + this.module_name + ":" + str(line) + "*/\n" + result
        }
        return result
    }

    -- ── Statement handlers ──────────────────────────────

    fn stmt_ExpressionStatement(node) {
        return this._indent() + this.emit_expr(node.expression) + ";"
    }

    fn stmt_LetStatement(node) {
        let keyword = if node.mutable { "let" } else { "const" }
        let val = this.emit_expr(node.value)
        let name = this._safe_name(node.name)
        return this._indent() + keyword + " " + name + " = " + val + ";"
    }

    fn stmt_DestructureLetStatement(node) {
        let keyword = if node.mutable { "let" } else { "const" }
        let val = this.emit_expr(node.value)
        mut target_parts = []
        for t in node.targets {
            if type(t) == "string" {
                push(target_parts, this._safe_name(t))
            } else {
                push(target_parts, this.emit_expr(t))
            }
        }
        let targets_str = join(target_parts, ", ")
        if node.kind == "list" {
            return this._indent() + keyword + " [" + targets_str + "] = " + val + ";"
        } else {
            return this._indent() + keyword + " {" + targets_str + "} = " + val + ";"
        }
    }

    fn stmt_AssignStatement(node) {
        let target = this.emit_expr(node.target)
        let val = this.emit_expr(node.value)
        return this._indent() + target + " " + node.operator + " " + val + ";"
    }

    fn stmt_MultiAssignStatement(node) {
        mut lines = []
        mut i = 0
        while i < len(node.targets) {
            push(lines, this._indent() + this.emit_expr(node.targets[i]) + " = " + this.emit_expr(node.values[i]) + ";")
            i += 1
        }
        return join(lines, "\n")
    }

    fn stmt_FnStatement(node) {
        let name = this._safe_name(node.name)
        let params = this._emit_params(node.params)
        let prefix = if node.is_async { "async " } else { "" }
        let body = this._emit_block_body(node.body)
        return this._indent() + prefix + "function " + name + "(" + params + ") {\n" + body + "\n" + this._indent() + "}"
    }

    fn stmt_ReturnStatement(node) {
        if node.value != null {
            return this._indent() + "return " + this.emit_expr(node.value) + ";"
        }
        return this._indent() + "return;"
    }

    fn stmt_IfStatement(node) {
        let cond = this.emit_expr(node.condition)
        let body = this._emit_block_body(node.body)
        mut result = this._indent() + "if ($truthy(" + cond + ")) {\n" + body + "\n" + this._indent() + "}"

        if node.elif_clauses != null and len(node.elif_clauses) > 0 {
            for clause in node.elif_clauses {
                let c = this.emit_expr(clause[0])
                let b = this._emit_block_body(clause[1])
                result = result + " else if ($truthy(" + c + ")) {\n" + b + "\n" + this._indent() + "}"
            }
        }

        if node.else_body != null {
            let b = this._emit_block_body(node.else_body)
            result = result + " else {\n" + b + "\n" + this._indent() + "}"
        }

        return result
    }

    fn stmt_ForStatement(node) {
        let var_name = this._safe_name(node.variable)
        let iterable = this.emit_expr(node.iterable)
        let body = this._emit_block_body(node.body)
        return this._indent() + "for (const " + var_name + " of " + iterable + ") {\n" + body + "\n" + this._indent() + "}"
    }

    fn stmt_WhileStatement(node) {
        let cond = this.emit_expr(node.condition)
        let body = this._emit_block_body(node.body)
        return this._indent() + "while ($truthy(" + cond + ")) {\n" + body + "\n" + this._indent() + "}"
    }

    fn stmt_TryCatch(node) {
        let try_body = this._emit_block_body(node.try_body)
        let var_name = if node.catch_var != null { this._safe_name(node.catch_var) } else { "_e" }
        let catch_body = this._emit_block_body(node.catch_body)
        mut result = this._indent() + "try {\n" + try_body + "\n" + this._indent() + "}"
        result = result + " catch (" + var_name + ") {\n" + catch_body + "\n" + this._indent() + "}"
        if node.finally_body != null {
            let fin = this._emit_block_body(node.finally_body)
            result = result + " finally {\n" + fin + "\n" + this._indent() + "}"
        }
        return result
    }

    fn stmt_ThrowStatement(node) {
        let val = this.emit_expr(node.value)
        return this._indent() + "throw " + val + ";"
    }

    fn stmt_ShowStatement(node) {
        mut parts = []
        for v in node.values {
            push(parts, this.emit_expr(v))
        }
        return this._indent() + "$show(" + join(parts, ", ") + ");"
    }

    fn stmt_ImportStatement(node) {
        if node.path != null {
            -- File import: from "file.clarity" import x, y
            mut js_path = replace(node.path, ".clarity", ".js")
            if not starts(js_path, "./") and not starts(js_path, "/") {
                js_path = "./" + js_path
            }
            mut import_line = ""
            if node.names != null and len(node.names) > 0 {
                mut name_parts = []
                for n in node.names {
                    push(name_parts, this._safe_name(n))
                }
                import_line = "import { " + join(name_parts, ", ") + " } from \"" + js_path + "\";"
            } else {
                let alias = if node.alias != null { this._safe_name(node.alias) } else { this._safe_name(replace(node.path, ".clarity", "")) }
                import_line = "import * as " + alias + " from \"" + js_path + "\";"
            }
            -- JS imports must be at module top level — hoist if nested
            if this.indent_level > 0 {
                push(this.hoisted_imports, import_line)
                return this._indent() + "/* import hoisted: " + js_path + " */"
            }
            return this._indent() + import_line
        } elif node.module != null {
            -- Module import: import math
            return this._indent() + "// module import: " + node.module + " (provided by runtime)"
        }
        return this._indent() + "/* import */"
    }

    fn stmt_ClassStatement(node) {
        let name = this._safe_name(node.name)
        push(this.classes, node.name)
        let parent = if node.parent != null { " extends " + this._safe_name(node.parent) } else { "" }
        mut lines = [this._indent() + "class " + name + parent + " {"]
        this.indent_level += 1
        for method in node.methods {
            if method.node_type == "FnStatement" {
                mut mname = method.name
                if mname == "init" { mname = "constructor" }
                let params = this._emit_params(method.params)
                let body = this._emit_block_body(method.body)
                push(lines, this._indent() + mname + "(" + params + ") {")
                push(lines, body)
                push(lines, this._indent() + "}")
            }
        }
        this.indent_level -= 1
        push(lines, this._indent() + "}")
        return join(lines, "\n")
    }

    fn stmt_MatchStatement(node) {
        let subject = this.emit_expr(node.subject)
        let tmp = "__match_val"
        mut lines = [this._indent() + "const " + tmp + " = " + subject + ";"]
        mut first = true
        for arm in node.arms {
            mut pattern = null
            mut guard = null
            mut body = null
            if len(arm) == 3 {
                pattern = arm[0]
                guard = arm[1]
                body = arm[2]
            } else {
                pattern = arm[0]
                body = arm[1]
            }
            let kw = if first { "if" } else { "else if" }
            let pat = this.emit_expr(pattern)
            mut cond = tmp + " === " + pat
            if guard != null {
                cond = cond + " && $truthy(" + this.emit_expr(guard) + ")"
            }
            let b = this._emit_block_body(body)
            push(lines, this._indent() + kw + " (" + cond + ") {")
            push(lines, b)
            push(lines, this._indent() + "}")
            first = false
        }
        if node.default != null {
            let b = this._emit_block_body(node.default)
            push(lines, this._indent() + "else {")
            push(lines, b)
            push(lines, this._indent() + "}")
        }
        return join(lines, "\n")
    }

    fn stmt_EnumStatement(node) {
        let name = this._safe_name(node.name)
        mut members = []
        mut i = 0
        for member in node.members {
            let mname = member[0]
            let mval = member[1]
            if mval != null {
                push(members, "\"" + mname + "\": " + this.emit_expr(mval))
            } else {
                push(members, "\"" + mname + "\": " + str(i))
            }
            i += 1
        }
        let inner = join(members, ", ")
        return this._indent() + "const " + name + " = new $ClarityEnum(\"" + node.name + "\", {" + inner + "});"
    }

    fn stmt_DecoratedStatement(node) {
        let target_code = this.emit_stmt(node.target)
        mut name = null
        try { name = node.target.name } catch e {}
        if name != null and node.decorators != null and len(node.decorators) > 0 {
            mut lines = [target_code]
            mut i = len(node.decorators) - 1
            while i >= 0 {
                let dec_expr = this.emit_expr(node.decorators[i])
                let safe = this._safe_name(name)
                push(lines, this._indent() + safe + " = " + dec_expr + "(" + safe + ");")
                i -= 1
            }
            return join(lines, "\n")
        }
        return target_code
    }

    -- ── Expression dispatch ─────────────────────────────

    fn emit_expr(node) {
        if node == null { return "null" }
        let nt = node.node_type

        if nt == "NumberLiteral" { return str(node.value) }
        elif nt == "StringLiteral" { return this.expr_StringLiteral(node) }
        elif nt == "BoolLiteral" { return if node.value { "true" } else { "false" } }
        elif nt == "NullLiteral" { return "null" }
        elif nt == "Identifier" { return this._safe_name(node.name) }
        elif nt == "ThisExpression" { return "this" }
        elif nt == "ListLiteral" { return this.expr_ListLiteral(node) }
        elif nt == "MapLiteral" { return this.expr_MapLiteral(node) }
        elif nt == "BinaryOp" { return this.expr_BinaryOp(node) }
        elif nt == "UnaryOp" { return this.expr_UnaryOp(node) }
        elif nt == "CallExpression" { return this.expr_CallExpression(node) }
        elif nt == "MemberExpression" { return this.expr_MemberExpression(node) }
        elif nt == "OptionalMemberExpression" { return this.expr_OptionalMemberExpression(node) }
        elif nt == "IndexExpression" { return this.expr_IndexExpression(node) }
        elif nt == "SliceExpression" { return this.expr_SliceExpression(node) }
        elif nt == "FnExpression" { return this.expr_FnExpression(node) }
        elif nt == "PipeExpression" { return this.expr_PipeExpression(node) }
        elif nt == "RangeExpression" { return this.expr_RangeExpression(node) }
        elif nt == "AskExpression" { return "$ask(" + this.emit_expr(node.prompt) + ")" }
        elif nt == "NullCoalesce" { return "((" + this.emit_expr(node.left) + ") ?? (" + this.emit_expr(node.right) + "))" }
        elif nt == "SpreadExpression" { return "..." + this.emit_expr(node.value) }
        elif nt == "IfExpression" { return this.expr_IfExpression(node) }
        elif nt == "ComprehensionExpression" { return this.expr_ComprehensionExpression(node) }
        elif nt == "MapComprehensionExpression" { return this.expr_MapComprehensionExpression(node) }
        elif nt == "AwaitExpression" { return "(await " + this.emit_expr(node.value) + ")" }
        elif nt == "YieldExpression" { return this.expr_YieldExpression(node) }
        else { return "/* TODO expr: " + nt + " */" }
    }

    -- ── Expression handlers ─────────────────────────────

    fn expr_StringLiteral(node) {
        let s = node.value
        if contains(s, "{") and contains(s, "}") {
            -- Convert Clarity string interpolation to JS template literals
            let result = this._convert_interpolation(s)
            return "`" + result + "`"
        }
        -- Escape and use regular string
        let escaped = replace(replace(s, "\\", "\\\\"), "\"", "\\\"")
        return "\"" + escaped + "\""
    }

    fn expr_ListLiteral(node) {
        mut parts = []
        for el in node.elements {
            if el.node_type == "SpreadExpression" {
                push(parts, "..." + this.emit_expr(el.value))
            } else {
                push(parts, this.emit_expr(el))
            }
        }
        return "[" + join(parts, ", ") + "]"
    }

    fn expr_MapLiteral(node) {
        mut pairs = []
        for pair in node.pairs {
            let k = pair[0]
            let v = pair[1]
            if k == null and v.node_type == "SpreadExpression" {
                push(pairs, "..." + this.emit_expr(v.value))
            } else {
                push(pairs, "[" + this.emit_expr(k) + "]: " + this.emit_expr(v))
            }
        }
        return "{" + join(pairs, ", ") + "}"
    }

    fn expr_BinaryOp(node) {
        let left = this.emit_expr(node.left)
        let right = this.emit_expr(node.right)
        mut op = node.operator

        -- Map Clarity operators to JS
        if op == "and" { op = "&&" }
        elif op == "or" { op = "||" }

        if op == "+" {
            return "(" + left + " + " + right + ")"
        }
        return "(" + left + " " + op + " " + right + ")"
    }

    fn expr_UnaryOp(node) {
        let operand = this.emit_expr(node.operand)
        if node.operator == "not" {
            return "(!$truthy(" + operand + "))"
        }
        return "(" + node.operator + operand + ")"
    }

    fn expr_CallExpression(node) {
        let callee = this.emit_expr(node.callee)
        mut arg_parts = []
        for a in node.arguments {
            push(arg_parts, this.emit_expr(a))
        }
        let args_str = join(arg_parts, ", ")
        -- In Clarity, class instantiation looks like a function call.
        -- In JS, classes require `new`.
        if node.callee.node_type == "Identifier" and contains(this.classes, node.callee.name) {
            return "new " + callee + "(" + args_str + ")"
        }
        return callee + "(" + args_str + ")"
    }

    fn expr_MemberExpression(node) {
        let obj = this.emit_expr(node.object)
        let prop = this._safe_name(node.property)
        return obj + "." + prop
    }

    fn expr_OptionalMemberExpression(node) {
        let obj = this.emit_expr(node.object)
        let prop = this._safe_name(node.property)
        return obj + "?." + prop
    }

    fn expr_IndexExpression(node) {
        let obj = this.emit_expr(node.object)
        let idx = this.emit_expr(node.index)
        return obj + "[" + idx + "]"
    }

    fn expr_SliceExpression(node) {
        let obj = this.emit_expr(node.object)
        let start_val = if node.start != null { this.emit_expr(node.start) } else { "0" }
        if node.end != null {
            return obj + ".slice(" + start_val + ", " + this.emit_expr(node.end) + ")"
        }
        return obj + ".slice(" + start_val + ")"
    }

    fn expr_FnExpression(node) {
        let params = this._emit_params(node.params)
        -- Check for single-return arrow shorthand
        let stmts = node.body.statements
        if len(stmts) == 1 and stmts[0].node_type == "ReturnStatement" {
            let val = this.emit_expr(stmts[0].value)
            return "((" + params + ") => " + val + ")"
        }
        let body = this._emit_block_body(node.body)
        return "(function(" + params + ") {\n" + body + "\n" + this._indent() + "})"
    }

    fn expr_PipeExpression(node) {
        let val = this.emit_expr(node.value)
        let fn_node = node.function
        if fn_node.node_type == "CallExpression" {
            let callee = this.emit_expr(fn_node.callee)
            mut arg_parts = []
            for a in fn_node.arguments {
                push(arg_parts, this.emit_expr(a))
            }
            let args_str = join(arg_parts, ", ")
            if len(args_str) > 0 {
                return callee + "(" + val + ", " + args_str + ")"
            }
            return callee + "(" + val + ")"
        }
        return this.emit_expr(fn_node) + "(" + val + ")"
    }

    fn expr_RangeExpression(node) {
        let start_val = this.emit_expr(node.start)
        let end_val = if node.end != null { this.emit_expr(node.end) } else { "undefined" }
        return "$range(" + start_val + ", " + end_val + ")"
    }

    fn expr_IfExpression(node) {
        let cond = this.emit_expr(node.condition)
        let true_expr = this.emit_expr(node.true_expr)
        let false_expr = this.emit_expr(node.false_expr)
        return "($truthy(" + cond + ") ? " + true_expr + " : " + false_expr + ")"
    }

    fn expr_ComprehensionExpression(node) {
        let var_name = this._safe_name(node.variable)
        let iterable = this.emit_expr(node.iterable)
        let expr = this.emit_expr(node.expr)
        if node.condition != null {
            let cond = this.emit_expr(node.condition)
            return iterable + ".filter((" + var_name + ") => $truthy(" + cond + ")).map((" + var_name + ") => " + expr + ")"
        }
        return iterable + ".map((" + var_name + ") => " + expr + ")"
    }

    fn expr_MapComprehensionExpression(node) {
        mut var_str = ""
        if type(node.variables) == "string" {
            var_str = this._safe_name(node.variables)
        } else {
            mut parts = []
            for v in node.variables {
                push(parts, this._safe_name(v))
            }
            var_str = join(parts, ", ")
        }
        let iterable = this.emit_expr(node.iterable)
        let key_expr = this.emit_expr(node.key_expr)
        let val_expr = this.emit_expr(node.value_expr)
        if node.condition != null {
            let cond = this.emit_expr(node.condition)
            return "Object.fromEntries(" + iterable + ".filter((" + var_str + ") => $truthy(" + cond + ")).map((" + var_str + ") => [" + key_expr + ", " + val_expr + "]))"
        }
        return "Object.fromEntries(" + iterable + ".map((" + var_str + ") => [" + key_expr + ", " + val_expr + "]))"
    }

    fn expr_YieldExpression(node) {
        if node.value != null {
            return "(yield " + this.emit_expr(node.value) + ")"
        }
        return "(yield)"
    }

    -- ── Helpers ──────────────────────────────────────────

    fn _emit_block_body(block) {
        this.indent_level += 1
        mut lines = []
        mut stmts = []
        try { stmts = block.statements } catch e {
            try { stmts = block.body } catch e2 {
                stmts = []
            }
        }
        for stmt in stmts {
            push(lines, this.emit_stmt(stmt))
        }
        this.indent_level -= 1
        return join(lines, "\n")
    }

    fn _emit_params(params) {
        mut parts = []
        for p in params {
            if type(p) == "string" {
                if starts(p, "...") {
                    push(parts, "..." + this._safe_name(substring(p, 3, len(p))))
                } else {
                    push(parts, this._safe_name(p))
                }
            } elif type(p) == "list" {
                let name = p[0]
                let default_val = if len(p) > 1 { p[1] } else { null }
                if type(name) == "string" and starts(name, "...") {
                    push(parts, "..." + this._safe_name(substring(name, 3, len(name))))
                } else {
                    let safe = if type(name) == "string" { this._safe_name(name) } else { str(name) }
                    if default_val != null {
                        push(parts, safe + " = " + this.emit_expr(default_val))
                    } else {
                        push(parts, safe)
                    }
                }
            } else {
                push(parts, str(p))
            }
        }
        return join(parts, ", ")
    }

    fn _safe_name(name) {
        if type(name) != "string" { return str(name) }
        if has(JS_RESERVED, name) { return JS_RESERVED[name] }
        return name
    }

    fn _convert_interpolation(s) {
        mut result = []
        mut i = 0
        while i < len(s) {
            let ch = char_at(s, i)
            if ch == "{" {
                -- Find matching close brace
                mut depth = 1
                mut j = i + 1
                while j < len(s) and depth > 0 {
                    let jch = char_at(s, j)
                    if jch == "{" { depth += 1 }
                    elif jch == "}" { depth -= 1 }
                    j += 1
                }
                let expr = substring(s, i + 1, j - 1)
                push(result, "${" + this._safe_name(expr) + "}")
                i = j
            } elif ch == "`" {
                push(result, "\\`")
                i += 1
            } elif ch == "\\" {
                if i + 1 < len(s) {
                    push(result, substring(s, i, i + 2))
                    i += 2
                } else {
                    push(result, "\\")
                    i += 1
                }
            } else {
                push(result, ch)
                i += 1
            }
        }
        return join(result, "")
    }
}

-- ── Public API ──────────────────────────────────────────

fn transpile_source(source, filename) {
    let fname = filename ?? "<input>"
    let tokens = tokenize(source, fname)
    let tree = parse(tokens, source)
    let emitter = JSEmitter(fname)
    let js_code = emitter.emit(tree)
    return js_code
}

fn transpile_file(path) {
    let source = read(path)
    -- Extract basename for module name
    let parts = split(path, "/")
    let basename = parts[len(parts) - 1]
    return transpile_source(source, basename)
}

fn transpile_with_runtime(path) {
    let js_code = transpile_file(path)
    return RUNTIME_HEADER + js_code
}

fn transpile_bundle(stdlib_dir, dist_dir) {
    -- Ensure dist directory exists
    exec("mkdir -p " + dist_dir)

    show "  Transpiling stdlib..."
    for fname in STDLIB_FILES {
        let src = stdlib_dir + "/" + fname
        if exists(src) {
            try {
                let js = transpile_with_runtime(src)
                let out = dist_dir + "/" + replace(fname, ".clarity", ".js")
                write(out, js)
                show "    " + fname + " -> " + replace(fname, ".clarity", ".js")
            } catch e {
                show "    " + fname + " -- SKIP (" + str(e) + ")"
            }
        }
    }

    -- Copy runtime.js
    let runtime_src = replace(stdlib_dir, "stdlib", "native") + "/runtime.js"
    let runtime_dst = dist_dir + "/runtime.js"
    if exists(runtime_src) {
        let runtime_content = read(runtime_src)
        write(runtime_dst, runtime_content)
        show "    runtime.js copied"
    }

    -- Create entry point
    let entry = dist_dir + "/clarity-entry.js"
    let entry_code = "#!/usr/bin/env bun\n// Clarity native entry point\nimport { clarityMain } from \"./runtime.js\";\nclarityMain(() => {\n  import(\"./cli.js\");\n});\n"
    write(entry, entry_code)
    show "    clarity-entry.js created"

    -- Create package.json
    write(dist_dir + "/package.json", "{\"type\": \"module\"}\n")

    show ""
    show "  Bundle ready at: " + dist_dir + "/"
    show "  Run with:   bun " + entry
    show "  Compile:    bun build --compile " + entry + " --outfile clarity"
}
