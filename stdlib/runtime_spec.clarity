-- Runtime Specification — defines all JavaScript runtime builtins.
-- This is the single source of truth for native/runtime.js.
-- Use `clarity gen-runtime` to regenerate runtime.js from this spec.

-- ── Node.js Imports ───────────────────────────────────────

let NODE_IMPORTS = [
    {module: "fs", names: ["readFileSync", "writeFileSync", "appendFileSync", "existsSync", "readdirSync", "mkdirSync", "unlinkSync", "renameSync", "statSync"]},
    {module: "child_process", names: ["execSync"]},
    {module: "readline", names: ["createInterface"]},
    {module: "http", names: ["createServer"]},
    {module: "path", names: ["resolve", "dirname", "basename", "extname"], aliases: {"join": "pathJoin", "sep": "sep"}},
    {module: "crypto", names: ["createHash", "randomUUID"]}
]

-- ── Section: I/O ──────────────────────────────────────────

let IO_SECTION = {
    label: "I/O",
    preamble: "const _output = [];",
    fns: [
        {name: "show", params: "...vals", body: "const text = vals.map(display).join(' ');\n  console.log(text);\n  _output.push(text);"},
        {name: "show", export_as: "print", kind: "alias"},
        {name: "ask", params: "prompt = ''", body: "process.stdout.write(prompt);\n  const buf = Buffer.alloc(1024);\n  const fd = process.platform === 'win32'\n    ? process.stdin.fd\n    : require('fs').openSync('/dev/tty', 'rs');\n  let n = 0;\n  try { n = require('fs').readSync(fd, buf, 0, buf.length, null); } catch { }\n  if (fd !== process.stdin.fd) require('fs').closeSync(fd);\n  return buf.slice(0, n).toString().replace(/[\\r\\n]+$/, '');"},
        {name: "read", params: "path", body: "return readFileSync(path, 'utf-8');"},
        {name: "write", params: "path, content", body: "writeFileSync(path, display(content)); return true;"},
        {name: "append", params: "path, content", body: "appendFileSync(path, display(content)); return true;"},
        {name: "exists", params: "path", body: "return existsSync(path);"},
        {name: "lines", params: "path", body: "return readFileSync(path, 'utf-8').split('\\n');"}
    ]
}

-- ── Section: Type Conversions ─────────────────────────────

let TYPE_SECTION = {
    label: "Type conversions",
    fns: [
        {name: "$int", params: "v", body: "if (typeof v === 'string') return parseInt(v, 10) || 0;\n  return Math.trunc(Number(v));"},
        {name: "$float", params: "v", body: "return parseFloat(v);"},
        {name: "str", params: "v", body: "return display(v);"},
        {name: "$bool", params: "v", body: "return truthy(v);"},
        {name: "type", params: "v", body: "if (v === null || v === undefined) return 'null';\n  if (typeof v === 'boolean') return 'bool';\n  if (typeof v === 'number') return Number.isInteger(v) ? 'int' : 'float';\n  if (typeof v === 'string') return 'string';\n  if (Array.isArray(v)) return 'list';\n  if (v instanceof ClarityEnum) return 'enum';\n  if (v instanceof ClarityInstance) return v._className;\n  if (typeof v === 'object') return 'map';\n  if (typeof v === 'function') return 'function';\n  return 'unknown';"}
    ]
}

-- ── Section: Collections ──────────────────────────────────

let COLLECTIONS_SECTION = {
    label: "Collections",
    fns: [
        {name: "len", params: "v", body: "if (v === null || v === undefined) return 0;\n  if (typeof v === 'string' || Array.isArray(v)) return v.length;\n  if (typeof v === 'object') return Object.keys(v).length;\n  return 0;"},
        {name: "push", params: "list, item", body: "list.push(item); return list;"},
        {name: "pop", params: "list", body: "return list.pop();"},
        {name: "sort", params: "list", body: "return [...list].sort((a, b) => a < b ? -1 : a > b ? 1 : 0);"},
        {name: "reverse", params: "v", body: "if (typeof v === 'string') return v.split('').reverse().join('');\n  return [...v].reverse();"},
        {name: "range", params: "...args", body: "let start = 0, end = 0, step = 1;\n  if (args.length === 1) { end = args[0]; }\n  else if (args.length === 2) { start = args[0]; end = args[1]; }\n  else { start = args[0]; end = args[1]; step = args[2]; }\n  const result = [];\n  if (step > 0) for (let i = start; i < end; i += step) result.push(i);\n  else for (let i = start; i > end; i += step) result.push(i);\n  return result;"},
        {name: "map", params: "list, fn", body: "return list.map((v, i) => fn(v, i));"},
        {name: "filter", params: "list, fn", body: "return list.filter(fn);"},
        {name: "reduce", params: "list, fn, init", body: "return init !== undefined ? list.reduce(fn, init) : list.reduce(fn);"},
        {name: "each", params: "list, fn", body: "list.forEach(fn);"},
        {name: "find", params: "list, fn", body: "return list.find(fn) ?? null;"},
        {name: "every", params: "list, fn", body: "return list.every(fn);"},
        {name: "some", params: "list, fn", body: "return list.some(fn);"},
        {name: "flat", params: "list", body: "return list.flat();"},
        {name: "zip", params: "...lists", body: "const minLen = Math.min(...lists.map(l => l.length));\n  return Array.from({ length: minLen }, (_, i) => lists.map(l => l[i]));"},
        {name: "unique", params: "list", body: "return [...new Set(list)];"},
        {name: "keys", params: "obj", body: "return Object.keys(obj);"},
        {name: "values", params: "obj", body: "return Object.values(obj);"},
        {name: "entries", params: "obj", body: "return Object.entries(obj);"},
        {name: "merge", params: "...objs", body: "return Object.assign({}, ...objs);"},
        {name: "has", params: "obj, key", body: "if (Array.isArray(obj)) return obj.includes(key);\n  if (typeof obj === 'string') return obj.includes(key);\n  return obj != null && key in obj;"}
    ]
}

-- ── Section: Strings ──────────────────────────────────────

let STRINGS_SECTION = {
    label: "Strings",
    fns: [
        {name: "split", params: "s, sep = ' '", body: "return s.split(sep);"},
        {name: "$join", params: "list, sep = ''", body: "return list.map(display).join(sep);"},
        {name: "replace", params: "s, from, to", body: "return s.split(from).join(to);"},
        {name: "trim", params: "s", body: "return s.trim();"},
        {name: "upper", params: "s", body: "return s.toUpperCase();"},
        {name: "lower", params: "s", body: "return s.toLowerCase();"},
        {name: "contains", params: "s, sub", body: "if (Array.isArray(s)) return s.includes(sub);\n  return s.includes(sub);"},
        {name: "starts", params: "s, prefix", body: "return s.startsWith(prefix);"},
        {name: "ends", params: "s, suffix", body: "return s.endsWith(suffix);"},
        {name: "chars", params: "s", body: "return s.split('');"},
        {name: "$repeat", params: "s, n", body: "return s.repeat(n);"},
        {name: "pad_left", params: "s, n, ch = ' '", body: "return s.padStart(n, ch);"},
        {name: "pad_right", params: "s, n, ch = ' '", body: "return s.padEnd(n, ch);"},
        {name: "char_at", params: "s, i", body: "return s[i] ?? null;"},
        {name: "char_code", params: "s", body: "return s.charCodeAt(0);"},
        {name: "from_char_code", params: "n", body: "return String.fromCharCode(n);"},
        {name: "index_of", params: "s, sub", body: "return s.indexOf(sub);"},
        {name: "substring", params: "s, start, end", body: "return s.substring(start, end);"},
        {name: "is_digit", params: "c", body: "return c.length > 0 && /^\\d+$/.test(c);"},
        {name: "is_alpha", params: "c", body: "return c.length > 0 && /^[a-zA-Z]+$/.test(c);"},
        {name: "is_alnum", params: "c", body: "return c.length > 0 && /^[a-zA-Z0-9]+$/.test(c);"},
        {name: "is_space", params: "c", body: "return c.length > 0 && /^\\s+$/.test(c);"}
    ]
}

-- ── Section: Math ─────────────────────────────────────────

let MATH_SECTION = {
    label: "Math",
    constants: [
        {name: "pi", value: "Math.PI"},
        {name: "e", value: "Math.E"},
        {name: "sqrt", value: "Math.sqrt"},
        {name: "sin", value: "Math.sin"},
        {name: "cos", value: "Math.cos"},
        {name: "tan", value: "Math.tan"},
        {name: "log", value: "Math.log"}
    ],
    fns: [
        {name: "abs", params: "n", body: "return Math.abs(n);"},
        {name: "round", params: "n, d = 0", body: "const f = 10 ** d; return Math.round(n * f) / f;"},
        {name: "floor", params: "n", body: "return Math.floor(n);"},
        {name: "ceil", params: "n", body: "return Math.ceil(n);"},
        {name: "$min", params: "...args", body: "if (args.length === 1 && Array.isArray(args[0])) return Math.min(...args[0]);\n  return Math.min(...args);"},
        {name: "$max", params: "...args", body: "if (args.length === 1 && Array.isArray(args[0])) return Math.max(...args[0]);\n  return Math.max(...args);"},
        {name: "sum", params: "list", body: "return list.reduce((a, b) => a + b, 0);"},
        {name: "random", params: "...args", body: "if (args.length === 0) return Math.random();\n  if (args.length === 1) return Math.floor(Math.random() * args[0]);\n  return Math.floor(Math.random() * (args[1] - args[0])) + args[0];"},
        {name: "pow", params: "base, exp", body: "return base ** exp;"}
    ]
}

-- ── Section: System ───────────────────────────────────────

let SYSTEM_SECTION = {
    label: "System",
    fns: [
        {name: "exec", params: "cmd", body: "try { return execSync(cmd, { encoding: 'utf-8' }).replace(/\\n$/, ''); }\n  catch (e) { return e.stdout || ''; }"},
        {name: "exec_full", params: "cmd", body: "try {\n    const stdout = execSync(cmd, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] });\n    return { stdout, stderr: '', exit_code: 0 };\n  } catch (e) {\n    return { stdout: e.stdout || '', stderr: e.stderr || '', exit_code: e.status || 1 };\n  }"},
        {name: "exit", params: "code = 0", body: "process.exit(code);"},
        {name: "sleep", params: "secs", body: "execSync(`sleep ${secs}`);"},
        {name: "time", params: "", body: "return Date.now() / 1000;"},
        {name: "env", params: "name", body: "return process.env[name] || null;"},
        {name: "args", params: "", body: "return process.argv.slice(2);"},
        {name: "cwd", params: "", body: "return process.cwd();"}
    ]
}

-- ── Section: JSON ─────────────────────────────────────────

let JSON_SECTION = {
    label: "JSON",
    fns: [
        {name: "json_parse", params: "s", body: "return JSON.parse(s);"},
        {name: "json_string", params: "v, indent", body: "return JSON.stringify(v, null, indent);"}
    ]
}

-- ── Section: Crypto / Encoding ────────────────────────────

let CRYPTO_SECTION = {
    label: "Crypto / Encoding",
    fns: [
        {name: "hash", params: "text, algo = 'sha256'", body: "return createHash(algo).update(text).digest('hex');"},
        {name: "encode64", params: "text", body: "return Buffer.from(text).toString('base64');"},
        {name: "decode64", params: "text", body: "return Buffer.from(text, 'base64').toString();"}
    ]
}

-- ── Section: Functional ───────────────────────────────────

let FUNCTIONAL_SECTION = {
    label: "Functional",
    fns: [
        {name: "compose", params: "...fns", body: "return (x) => fns.reduceRight((v, fn) => fn(v), x);"},
        {name: "tap", params: "v, fn", body: "fn(v); return v;"}
    ]
}

-- ── Section: Set ──────────────────────────────────────────

let SET_SECTION = {
    label: "Set",
    fns: [
        {name: "$set", params: "list", body: "return [...new Set(list)];"}
    ]
}

-- ── Section: Error ────────────────────────────────────────

let ERROR_SECTION = {
    label: "Error",
    fns: [
        {name: "error", params: "msg", body: "return new Error(msg);"}
    ]
}

-- ── Section: HTTP ─────────────────────────────────────────

let HTTP_SECTION = {
    label: "HTTP",
    fns: [
        {name: "fetch", params: "url", body: "return execSync(`curl -sL '${url}'`, { encoding: 'utf-8' });"},
        {name: "serve", params: "port, handler", body: "const server = createServer((req, res) => {\n    const result = handler(req.method, req.url);\n    if (typeof result === 'object' && result !== null) {\n      res.writeHead(result.status || 200, { 'Content-Type': result.type || 'text/html' });\n      res.end(result.body || '');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(display(result));\n    }\n  });\n  server.listen(port);\n  console.log(`  Serving on http://localhost:${port}`);"}
    ]
}

-- ── Section: Regex ────────────────────────────────────────

let REGEX_SECTION = {
    label: "Regex",
    fns: [
        {name: "regex_match", params: "pattern, str", body: "return new RegExp(pattern).test(str);"},
        {name: "regex_search", params: "pattern, str", body: "return new RegExp(pattern).test(str);"},
        {name: "regex_find", params: "pattern, str", body: "return [...str.matchAll(new RegExp(pattern, 'g'))].map(m => m[0]);"},
        {name: "regex_replace", params: "pattern, str, repl", body: "return str.replace(new RegExp(pattern, 'g'), repl);"},
        {name: "regex_split", params: "pattern, str", body: "return str.split(new RegExp(pattern));"},
        {name: "exec_full_regex", params: "pattern, str", body: "const re = new RegExp(pattern);\n  const m = re.exec(str);\n  if (!m) return null;\n  return { match: m[0], groups: m.slice(1), index: m.index };"}
    ]
}

-- ── Section: Classes ──────────────────────────────────────

let CLASSES_SECTION = {
    label: "Classes support",
    classes: [
        {name: "ClarityInstance", body: "constructor(className, props = {}) {\n    this._className = className;\n    Object.assign(this, props);\n  }"},
        {name: "ClarityEnum", body: "constructor(name, members) {\n    this.name = name;\n    this.members = members;\n    for (const [k, v] of Object.entries(members)) {\n      this[k] = v;\n    }\n  }\n  toString() { return `<enum ${this.name}>`; }"}
    ]
}

-- ── Section: Path module ──────────────────────────────────

let PATH_MODULE_SECTION = {
    label: "Path module",
    objects: [
        {name: "$path", body: "join: pathJoin,\n  dir: dirname,\n  name: basename,\n  stem: (p) => basename(p, extname(p)),\n  ext: extname,\n  exists: existsSync,\n  is_file: (p) => { try { return statSync(p).isFile(); } catch { return false; } },\n  is_dir: (p) => { try { return statSync(p).isDirectory(); } catch { return false; } },\n  abs: resolve,\n  sep,"}
    ]
}

-- ── Section: OS module ────────────────────────────────────

let OS_MODULE_SECTION = {
    label: "OS module",
    objects: [
        {name: "$os", body: "env: (n) => process.env[n] || null,\n  cwd: () => process.cwd(),\n  args: () => process.argv.slice(2),\n  exec: exec,\n  ls: (p = '.') => readdirSync(p),\n  mkdir: (p) => mkdirSync(p, { recursive: true }),\n  rm: unlinkSync,\n  rename: renameSync,\n  home: () => process.env.HOME || process.env.USERPROFILE || '/',\n  sep,"}
    ]
}

-- ── Section: Display helpers ──────────────────────────────

let DISPLAY_SECTION = {
    label: "Display helpers",
    fns: [
        {name: "display", params: "value", body: "if (value === null || value === undefined) return 'null';\n  if (typeof value === 'boolean') return value ? 'true' : 'false';\n  if (typeof value === 'number') {\n    if (Number.isInteger(value)) return String(value);\n    return String(value);\n  }\n  if (typeof value === 'string') return value;\n  if (Array.isArray(value)) return '[' + value.map(display).join(', ') + ']';\n  if (value instanceof ClarityEnum) return value.toString();\n  if (value instanceof ClarityInstance) return `<${value._className} instance>`;\n  if (typeof value === 'function') return `<fn ${value.name || 'anonymous'}>`;\n  if (typeof value === 'object') {\n    const pairs = Object.entries(value).map(([k, v]) => `${k}: ${repr(v)}`);\n    return '{' + pairs.join(', ') + '}';\n  }\n  return String(value);"},
        {name: "repr", params: "value", body: "if (typeof value === 'string') return `\"${value}\"`;\n  return display(value);"},
        {name: "truthy", params: "value", body: "if (value === null || value === undefined) return false;\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'number') return value !== 0;\n  if (typeof value === 'string') return value.length > 0;\n  if (Array.isArray(value)) return value.length > 0;\n  return true;"}
    ]
}

-- ── Section: Control flow signals ─────────────────────────

let SIGNALS_SECTION = {
    label: "Signal classes for control flow",
    classes: [
        {name: "BreakSignal", body: ""},
        {name: "ContinueSignal", body: ""},
        {name: "ReturnSignal", body: "constructor(value) { this.value = value; }"}
    ]
}

-- ── Section: Error formatting ─────────────────────────────

let ERROR_FMT_SECTION = {
    label: "Error formatting with Clarity source mapping",
    fns: [
        {name: "formatClarityError", params: "err, source", body: "if (!(err instanceof Error)) return display(err);\n  const jsStack = err.stack || '';\n  const lines = jsStack.split('\\n');\n  const clarityFrames = [];\n  const linePattern = /at\\s+(?:(\\S+)\\s+)?\\(?.*?:(\\d+):\\d+\\)?/;\n  for (const line of lines) {\n    const m = line.match(linePattern);\n    if (m) {\n      const fnName = m[1] || '<module>';\n      clarityFrames.push(`  at ${fnName}`);\n    }\n  }\n  let msg = `\\x1b[31m\\n  Clarity Error: ${err.message}\\x1b[0m`;\n  if (clarityFrames.length > 0) {\n    msg += '\\n' + clarityFrames.slice(0, 8).join('\\n');\n  }\n  return msg;"},
        {name: "clarityMain", params: "fn", body: "try {\n    fn();\n  } catch (err) {\n    if (err instanceof BreakSignal || err instanceof ContinueSignal || err instanceof ReturnSignal) return;\n    console.error(formatClarityError(err));\n    process.exit(1);\n  }"}
    ]
}

-- ── All sections in order ─────────────────────────────────

let ALL_SECTIONS = [
    IO_SECTION,
    TYPE_SECTION,
    COLLECTIONS_SECTION,
    STRINGS_SECTION,
    MATH_SECTION,
    SYSTEM_SECTION,
    JSON_SECTION,
    CRYPTO_SECTION,
    FUNCTIONAL_SECTION,
    SET_SECTION,
    ERROR_SECTION,
    HTTP_SECTION,
    REGEX_SECTION,
    CLASSES_SECTION,
    PATH_MODULE_SECTION,
    OS_MODULE_SECTION,
    DISPLAY_SECTION,
    SIGNALS_SECTION,
    ERROR_FMT_SECTION
]

-- ── Aliases (re-exports) ─────────────────────────────────

let ALIASES = [
    {name: "show", export_as: "print"}
]
